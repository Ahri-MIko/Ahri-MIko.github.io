{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/particlex/source/css/cursor.min.css","path":"css/cursor.min.css","modified":0,"renderable":1},{"_id":"themes/particlex/source/css/main.css","path":"css/main.css","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":1},{"_id":"themes/particlex/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/background.min.js","path":"js/background.min.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/cursor.min.js","path":"js/cursor.min.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/fireworks.min.js","path":"js/fireworks.min.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/crypto.js","path":"js/lib/crypto.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/highlight.js","path":"js/lib/highlight.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/home.js","path":"js/lib/home.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/math.js","path":"js/lib/math.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/preview.js","path":"js/lib/preview.js","modified":0,"renderable":1},{"_id":"themes/particlex/source/js/lib/search.js","path":"js/lib/search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/C-事件详解.md","hash":"590fbf7780f021f7cc56a32471ae3d97f3bae299","modified":1727569508555},{"_id":"source/_posts/Foot-IK.md","hash":"c94f9f5d5cff7ea69decbbba9b5e469fbb8264e5","modified":1727438396298},{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1727436622998},{"_id":"source/_posts/C-事件详解/事件1.jpg","hash":"e226f9eff27a6324a3ffa63d46a2b968cd64d223","modified":1727568926202},{"_id":"source/_posts/C-事件详解/事件2.jpg","hash":"5c598197dcf7b83b90618e2365881a62c3ecc84c","modified":1727569019213},{"_id":"source/_posts/C-事件详解/事件三.jpg","hash":"44e5fdf23ef71f543fbde396e2c36df597e2b432","modified":1727569098171},{"_id":"source/_posts/Foot-IK/footik.jpg","hash":"f14b5d24c2526f8f7b53040b517d81e730fb4382","modified":1727438325142},{"_id":"source/_posts/C-事件详解/event.jpg","hash":"f42f6dbd78fc84c8d34f5558dd89d540ae076e26","modified":1727568793985},{"_id":"source/_posts/Foot-IK/NO.01.001.jpg","hash":"6148a9ba74c94aaa87610099f24f6700dfea1c28","modified":1727429674214},{"_id":"themes/particlex/source/css/cursor.min.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1727250129087},{"_id":"themes/particlex/.gitignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1727244158487},{"_id":"themes/particlex/.npmignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1727244158488},{"_id":"themes/particlex/LICENSE","hash":"c42335f46096b2ec5509087ab122e5dfd43e2cf4","modified":1727244158489},{"_id":"themes/particlex/_config.yml","hash":"18b71c24b00ad96b286f827ff13e8b2d5d261164","modified":1727435759302},{"_id":"themes/particlex/package.json","hash":"db00b08d699e394ba9c88edcf280792075e35654","modified":1727244158502},{"_id":"themes/particlex/README.md","hash":"19b124670bc5c9aa8cff0fc191be1e9a40c841a0","modified":1727244158490},{"_id":"themes/particlex/.github/dependabot.yml","hash":"d2adc8df9ae7f28520d2fd5c0579e75dbe352bdc","modified":1727244158487},{"_id":"themes/particlex/layout/card.ejs","hash":"65e0c46a79c02212982c8a9aef1b16bfc3430429","modified":1727244158493},{"_id":"themes/particlex/pnpm-lock.yaml","hash":"4c7a4f39b776af75374d0dc6f6619dcbf0e58b97","modified":1727244158503},{"_id":"themes/particlex/layout/comment.ejs","hash":"267809e50962af7ab6bc5892855f765d754a62e4","modified":1727244158494},{"_id":"themes/particlex/layout/archives.ejs","hash":"c3878ffe435aa37ba46a0ee25c34257c2f2a1d87","modified":1727244158492},{"_id":"themes/particlex/layout/categories.ejs","hash":"73ff20a582c72e7cf138c7b42006447e4a2e110a","modified":1727244158493},{"_id":"themes/particlex/layout/current.ejs","hash":"4e75c06c9d0b1336c69c210567581e7efded5621","modified":1727244158494},{"_id":"themes/particlex/layout/footer.ejs","hash":"357b2db2eab031150e06dd47695dc9916d875fc4","modified":1727244158495},{"_id":"themes/particlex/layout/import.ejs","hash":"7800720150b46a9abaf513316602a05293b3991b","modified":1727244158496},{"_id":"themes/particlex/layout/index.ejs","hash":"e7c208f1d9c0acb24f20180ffa45f48ee5ea5d71","modified":1727244158497},{"_id":"themes/particlex/layout/layout.ejs","hash":"145adea6662a9c41d9d93647d5d858fc29b30214","modified":1727255529628},{"_id":"themes/particlex/layout/menu.ejs","hash":"1c78bd05cdfb3ae7a47ed572229a1970335fe8b8","modified":1727244158499},{"_id":"themes/particlex/layout/post.ejs","hash":"a3e567ac00d1ccd8a84525d20665318248da75a7","modified":1727244158500},{"_id":"themes/particlex/layout/posts.ejs","hash":"18209210f37d7e8775ca54e4724ce66ad09d873f","modified":1727244158501},{"_id":"themes/particlex/layout/tags.ejs","hash":"f5b821d45f2f44443adade62eb032f92215e0d62","modified":1727244158501},{"_id":"themes/particlex/source/css/main.css","hash":"ff49d90e3eb12de20b68a95c028a44d8d5f28a2e","modified":1727244158505},{"_id":"themes/particlex/source/images/avatar.jpg","hash":"3843e0ab979435baf2c3aa1b1c3092c2aceefe78","modified":1727250931510},{"_id":"themes/particlex/source/images/loading.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1727244158514},{"_id":"themes/particlex/source/js/cursor.min.js","hash":"b28f1d6d855cf8d4805eee1ca5aa6fa4d4213111","modified":1727250119337},{"_id":"themes/particlex/source/js/background.min.js","hash":"0b75485c0e7e4c1c00728408b814900ba5103def","modified":1727250026567},{"_id":"themes/particlex/source/js/fireworks.min.js","hash":"6f5ccef48af055cb6f4419b6b6d5990678cb502c","modified":1727249848957},{"_id":"themes/particlex/source/js/main.js","hash":"420d9ab7f2e0cb44bdc5335389344ec1e7253db5","modified":1727244158521},{"_id":"themes/particlex/source/js/lib/crypto.js","hash":"3db8692ac636d9f72dc94127216d21f9793e6602","modified":1727244158516},{"_id":"themes/particlex/source/js/lib/highlight.js","hash":"58fdb5f2d5e409bfc10aac6ccc464c87327806a5","modified":1727244158517},{"_id":"themes/particlex/source/js/lib/home.js","hash":"5ec113e1d72efaab5eb31addc05eb9dcf26ce1af","modified":1727244158517},{"_id":"themes/particlex/source/js/lib/math.js","hash":"f7716e83ef236818239fcae91defe730d5bfbc6d","modified":1727244158518},{"_id":"themes/particlex/source/js/lib/preview.js","hash":"d3050c6ed6d52e451cc1810843c5d595eadb8e5a","modified":1727244158519},{"_id":"themes/particlex/source/js/lib/search.js","hash":"d507facc680300c046f2b967279959541313e1f9","modified":1727244158520},{"_id":"source/_posts/Foot-IK/anbi2.jpg","hash":"1de1849f014fdd037c9d30b6c9a3ad35745e0ed3","modified":1727429981330},{"_id":"source/_posts/Foot-IK/anbi3.jpg","hash":"c6774131d6e9d106b237bae5d6ad73e616f2091d","modified":1727429992935},{"_id":"source/_posts/Foot-IK/anbi1.jpg","hash":"3dfb1223bb4ef31941d7d82036d107c4febd7df5","modified":1727429944177},{"_id":"themes/particlex/source/images/background.jpg","hash":"d16a7cd9d42d94c1d877bcdb5ba97a5431fc4cd8","modified":1727250833198},{"_id":"public/2024/09/29/C-事件详解/index.html","hash":"5f1fee5c785cd69c1ab247ebd7c35090f2df6456","modified":1728318108118},{"_id":"public/2024/09/27/Foot-IK/index.html","hash":"330209fc7ca9c3da578a419457e2f99414bc3458","modified":1728318108118},{"_id":"public/2024/09/25/hello-world/index.html","hash":"b7b586c702ee794580ffa5e8c749aa4360ceeda4","modified":1727570174741},{"_id":"public/archives/index.html","hash":"9420bedd86ed2b7adca0754a8a961a9176a457ac","modified":1728318108118},{"_id":"public/tags/Unity-3d-C/index.html","hash":"e13c1aaa9c639f9b272aa2482f1f2db384cdb226","modified":1728318108118},{"_id":"public/index.html","hash":"d41d1760023620facc59aa03a36f4a907e2ce3e0","modified":1728318108118},{"_id":"public/images/loading.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1727570174741},{"_id":"public/images/avatar.jpg","hash":"3843e0ab979435baf2c3aa1b1c3092c2aceefe78","modified":1727570174741},{"_id":"public/css/cursor.min.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1727570174741},{"_id":"public/js/background.min.js","hash":"0b75485c0e7e4c1c00728408b814900ba5103def","modified":1727570174741},{"_id":"public/css/main.css","hash":"444ff8856c320913dde037c43f24bba18ef4d741","modified":1727570174741},{"_id":"public/js/cursor.min.js","hash":"b28f1d6d855cf8d4805eee1ca5aa6fa4d4213111","modified":1727570174741},{"_id":"public/js/fireworks.min.js","hash":"6f5ccef48af055cb6f4419b6b6d5990678cb502c","modified":1727570174741},{"_id":"public/js/lib/highlight.js","hash":"a9ee0fd40904e2e50ab5ecab4c718a49c095836f","modified":1727570174741},{"_id":"public/js/main.js","hash":"a9cb52bac89783c3957c77cbb4ffc8fbb93a92a1","modified":1727570174741},{"_id":"public/2024/09/29/C-事件详解/事件三.jpg","hash":"44e5fdf23ef71f543fbde396e2c36df597e2b432","modified":1727570174741},{"_id":"public/2024/09/29/C-事件详解/事件1.jpg","hash":"e226f9eff27a6324a3ffa63d46a2b968cd64d223","modified":1727570174741},{"_id":"public/2024/09/29/C-事件详解/事件2.jpg","hash":"5c598197dcf7b83b90618e2365881a62c3ecc84c","modified":1727570174741},{"_id":"public/2024/09/27/Foot-IK/footik.jpg","hash":"f14b5d24c2526f8f7b53040b517d81e730fb4382","modified":1727570174741},{"_id":"public/js/lib/crypto.js","hash":"bc4a0c41cf5b61faa204a2a820fc042b563142cf","modified":1727570174741},{"_id":"public/js/lib/math.js","hash":"24c182cd3f5dd1c0f0192ca4cc143de71e076d2a","modified":1727570174741},{"_id":"public/js/lib/preview.js","hash":"595cfc3aff107b8dd0fdda214995c6f1bb5be39a","modified":1727570174741},{"_id":"public/js/lib/home.js","hash":"c2bf22772fd052cff88a9b5f547a30a6eb97e545","modified":1727570174741},{"_id":"public/js/lib/search.js","hash":"b631b87fa126a9a4a81b60b1a0516f765879963e","modified":1727570174741},{"_id":"public/2024/09/29/C-事件详解/event.jpg","hash":"f42f6dbd78fc84c8d34f5558dd89d540ae076e26","modified":1727570174741},{"_id":"public/2024/09/27/Foot-IK/NO.01.001.jpg","hash":"6148a9ba74c94aaa87610099f24f6700dfea1c28","modified":1727570174741},{"_id":"public/2024/09/27/Foot-IK/anbi2.jpg","hash":"1de1849f014fdd037c9d30b6c9a3ad35745e0ed3","modified":1727570174741},{"_id":"public/2024/09/27/Foot-IK/anbi3.jpg","hash":"c6774131d6e9d106b237bae5d6ad73e616f2091d","modified":1727570174741},{"_id":"public/2024/09/27/Foot-IK/anbi1.jpg","hash":"3dfb1223bb4ef31941d7d82036d107c4febd7df5","modified":1727570174741},{"_id":"public/images/background.jpg","hash":"d16a7cd9d42d94c1d877bcdb5ba97a5431fc4cd8","modified":1727570174741}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"C#事件详解","date":"2024-09-29T00:09:50.000Z","_content":"\n关于 C#事件解析\n\n<!-- more -->\n\n# 一. 什么是事件\n\n## 1. 字面说明\n\n事件(Event): 通俗的解释就是“能够发生的事情”，并且事件都是隶属于某一个主体的，比如公司上市，那个上市这个事件就是隶属于公司。\n\n由上面的定义就可以知道，将事件抽象到代码当中就是，事件要隶属于一个类，也就是一个类的成员。\n\n在前面就已经讲过:\n\n- **属性**：让对象有了访问数据的功能\n- **方法**：让对象有了对数据加工的功能\n- **事件**：让对象有了通知能力，使对象有了能通风报信的成员\n\n## 2. 举个例子\n\n- **手机**：具备时间的对象\n- **人**：接受事件的对象，思考的过程就是事件处理器\n  ![](./C-事件详解/event.jpg)\n\n# 总的来说\n\n根据事件参数来响应事件。\n\n## 原理\n\n事件模型的两个“5”：\n\n- **“发生->响应”的五个部分**：\n  - “孩子 饿了 我 做饭”\n  - “闹钟 响了 我 上班”\n\n其中的第五个部分存在订阅关系：“这个孩子是由我来响应的”，“这个闹钟是我的”。也就是说由绑定的关系，这样一来就是五个部分了。\n\n- **“发生->响应”的五个动作**：\n  1. 有一个事件\n  2. 有一群人关注到这个事件\n  3. 事情发生了\n  4. 关心这个事件的人被通知\n  5. 拿到信息的人根据事件参数对事件进行处理\n\n## 小结\n\n事件是用来对象或者类之间的信息传递与动作协调。\n\n**事件 = 事件的通知 + 可选的事件的参数（详细信息）**\n\n## 事件的应用\n\n一个简单的小示例\n\n<pre><code class=\"csharp\">using System;\nusing System.Timers;\nnamespace Hanoi\n{\n \n    class Programme\n    {\n        static void Main(string[] args)\n        {\n            Timer timer = new Timer();//事件的发送者\n            timer.Interval = 1000;\n            Boy boy = new Boy();//事件的响应者\n            Gril gril = new Gril();\n            timer.Elapsed += gril.Action;\n            timer.Elapsed += boy.Action;//事件的订阅\n            timer.Start();\n            Console.ReadLine();\n        }\n    }\n \n    class Boy\n    {\n        internal void Action(object sender, ElapsedEventArgs e)//为了保持一致性,这里的定义是visual studio自动生成的\n        {\n            Console.WriteLine(\"Jump!!\");//事件处理器\n        }\n    }\n \n    class Gril\n    {\n        internal void Action(object sender, ElapsedEventArgs e)\n        {\n            Console.WriteLine(\"Song!\");\n        }\n    }\n \n}\n</code></pre>\n\n# 类型一:\n\n![](./C-事件详解/event.jpg)\n\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n{\n \n    class Programme\n    {\n        static void Main(string[] args)\n        {\n            Form form = new Form();\n            Recevier rev = new Recevier(form);\n            form.ShowDialog();\n        }\n    }\n \n    class Recevier\n    {\n        private Form form;\n        public Recevier(Form from)\n        {\n            if(from != null) \n            {\n                this.form = from;\n                this.form.Click += this.FormClicked;\n            }\n        }\n \n        private void FormClicked(object sender, EventArgs e)\n        {\n            this.form.Text = DateTime.Now.ToString();\n        }\n    }\n   \n \n}\n</code></pre>\n\n# 类型二:\n\n![](./C-事件详解/事件2.jpg)\n\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n{\n \n    class Programme\n    {\n        static void Main(string[] args)\n        {\n           MyForm form = new MyForm();\n           form.Click+=form.Action;\n            form.ShowDialog();\n        }\n    }\n    class MyForm : Form\n    {\n        internal void Action(object sender, EventArgs e)\n        {\n            this.Text = DateTime.Now.ToString();\n        }\n    }\n \n \n}\n</code></pre>\n\n# 类型三:\n\n![](./C-事件详解/事件三.jpg)\n\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n{\n \n    class Programme\n    {\n        static void Main(string[] args)\n        {\n            MyForm form = new MyForm(); \n            form.ShowDialog();\n        }\n    }\n \n    class MyForm:Form\n    {\n        private TextBox mytextbox;\n        private Button mybutton;\n        public MyForm()\n        {\n            mytextbox = new TextBox();\n            mybutton = new Button();\n            this.Controls.Add(mytextbox);\n            this.Controls.Add(mybutton);\n            mybutton.Height = 50;\n            mybutton.Left = 100;\n            mybutton.Top = 50;\n            mytextbox.Left = 100;\n            mybutton.Click+=this.Action;\n        }\n \n        private void Action(object sender, EventArgs e)\n        {\n            this.mytextbox.Text = \"Hello,World\";\n        }\n    }\n}\n</code></pre>\n\n# 制作自己的事件\n\n## 事件声明的完整格式\n\n可能会有一点点绕，但只要和委托事件结合起来，还是比较容易理解的。\n\n<pre><code class=\"csharp\">using System;\nusing System.Globalization;\nusing System.Windows.Forms;\nusing System.Threading;\nnamespace Hanoi\n{\n    class Programme\n    {\n        static void Main(string[] args)\n        {\n            Customer customer = new Customer();\n            Waiter waiter = new Waiter();\n            customer.Order += waiter.Action;//事件连接\n            customer.Action();\n        }\n    }\n \n \n    public class OrderArgs\n    {\n        public string Size { get; set; }\n        public string Name { get; set; }\n    }\n \n    public delegate void OrderHandller(Customer customer, OrderArgs e);\n    public class Customer\n    {\n        public int Bill { get; set; }\n        public void PaytheBill()\n        {\n            Console.WriteLine(\"I Will pay you {0} dollers\", Bill);\n        }\n        public OrderHandller orderHandller;\n        public event OrderHandller Order\n        {\n            add { orderHandller = value; }\n            remove { orderHandller = value; }\n        }\n        public void Action()\n        {\n            Console.WriteLine(\"Walking Into the resturant\");\n            for(int i=0;i<3;i++)\n            {\n                Console.WriteLine(\"da da da\");\n                Thread.Sleep(1000);\n            }\n            Console.WriteLine(\"Thinking .....\");\n            for(int i=0;i<3;i++)\n                Thread.Sleep(1000);\n            if(orderHandller != null)//这里是指事件发生了,有没有人响应\n            {\n                this.orderHandller(this, new OrderArgs() { Name = \"Pizza\", Size = \"large\" });\n            }\n        }\n \n    }\n    class Waiter\n    {\n        internal void Action(Customer customer, OrderArgs e)\n        {\n            switch(e.Size)\n            {\n                case \"large\":\n                    customer.Bill += 10;\n                    break;\n                case \"small\":\n                    customer.Bill += 5;\n                    break;\n                default:\n                    break;\n            }\n            Console.WriteLine(\"you shoud Pay{0} for the{1}\",customer.Bill, e.Name);\n            customer.PaytheBill();\n        }\n    }\n \n}\n</code></pre>\n\n## 事件声明简化版本\n\n<pre><code class=\"csharp\"> public OrderHandller orderHandller;\n public event OrderHandller Order\n {\n     add { orderHandller = value; }\n     remove { orderHandller = value; }\n }\n \nif(orderHandller!= null)//这里是指事件发生了,有没有人响应\n{\n    this.orderHandller(this, new OrderArgs() { Name = \"Pizza\", Size = \"large\" });\n}\n \n//将上述代码替换成\n public OrderHandller orderHandller;\npublic event OrderHandller Order;\n \nif(Order != null)//这里是指事件发生了,有没有人响应\n{\n    this.Order(this, new OrderArgs() { Name = \"Pizza\", Size = \"large\" });\n}\n</code></pre>\n\n## 用 C#自带的事件处理器处理事件\n\n<pre><code class=\"csharp\">using System;\nusing System.Globalization;\nusing System.Windows.Forms;\nusing System.Threading;\nnamespace Hanoi\n{\n    class Programme\n    {\n        static void Main(string[] args)\n        {\n            Customer customer = new Customer();\n            Waiter waiter = new Waiter();\n            customer.Order += waiter.Action;//事件连接\n            customer.Action();\n        }\n    }\n \n \n    public class OrderArgs:EventArgs\n    {\n        public string Size { get; set; }\n        public string Name { get; set; }\n    }\n    public class Customer\n    {\n        public int Bill { get; set; }\n        public void PaytheBill()\n        {\n            Console.WriteLine(\"I Will pay you {0} dollers\", Bill);\n        }\n        public event EventHandler Order;\n        public void Action()\n        {\n            Console.WriteLine(\"Walking Into the resturant\");\n            for(int i=0;i<3;i++)\n            {\n                Console.WriteLine(\"da da da\");\n                Thread.Sleep(1000);\n            }\n            Console.WriteLine(\"Thinking .....\");\n            for(int i=0;i<3;i++)\n                Thread.Sleep(1000);\n            if(Order != null)//这里是指事件发生了,有没有人响应\n            {\n                this.Order(this, new OrderArgs() { Name = \"Pizza\", Size = \"large\" });\n            }\n        }\n \n    }\n    class Waiter\n    {\n        internal void Action(object customer, EventArgs e)\n        {\n            Customer cus = customer as Customer;\n            OrderArgs args = e as OrderArgs;\n            switch(args.Size)\n            {\n                case \"large\":\n                    cus.Bill += 10;\n                    break;\n                case \"small\":\n                    cus.Bill += 5;\n                    break;\n                default:\n                    break;\n            }\n            Console.WriteLine(\"you shoud Pay{0} for the{1}\",cus.Bill, args.Name);\n            cus.PaytheBill();\n        }\n    }\n \n}\n</code></pre>\n\n事件的书写规范\n\n<pre><code class=\"csharp\">protected void OnOrder(object customer,OrderArgs args)\n{\n    if (Order != null)//这里是指事件发生了,有没有人响应\n    {\n        this.Order(customer, new OrderArgs() { Name = \"Pizza\", Size = \"large\" });\n    }\n}\n//事件的专属触发器用On+动词命名\n</code></pre>\n\n## 小结\n\n通过上述例子也可以得知,事件就是委托类型的包装器,包装器对委托的字段起到了限制的作用,也就是委托的参数只能由事件发起者自己来传递,而不由别人传递\n","source":"_posts/C-事件详解.md","raw":"---\ntitle: C#事件详解\ndate: 2024-09-29 08:09:50\ntags: Unity 3d C#\n---\n\n关于 C#事件解析\n\n<!-- more -->\n\n# 一. 什么是事件\n\n## 1. 字面说明\n\n事件(Event): 通俗的解释就是“能够发生的事情”，并且事件都是隶属于某一个主体的，比如公司上市，那个上市这个事件就是隶属于公司。\n\n由上面的定义就可以知道，将事件抽象到代码当中就是，事件要隶属于一个类，也就是一个类的成员。\n\n在前面就已经讲过:\n\n- **属性**：让对象有了访问数据的功能\n- **方法**：让对象有了对数据加工的功能\n- **事件**：让对象有了通知能力，使对象有了能通风报信的成员\n\n## 2. 举个例子\n\n- **手机**：具备时间的对象\n- **人**：接受事件的对象，思考的过程就是事件处理器\n  ![](./C-事件详解/event.jpg)\n\n# 总的来说\n\n根据事件参数来响应事件。\n\n## 原理\n\n事件模型的两个“5”：\n\n- **“发生->响应”的五个部分**：\n  - “孩子 饿了 我 做饭”\n  - “闹钟 响了 我 上班”\n\n其中的第五个部分存在订阅关系：“这个孩子是由我来响应的”，“这个闹钟是我的”。也就是说由绑定的关系，这样一来就是五个部分了。\n\n- **“发生->响应”的五个动作**：\n  1. 有一个事件\n  2. 有一群人关注到这个事件\n  3. 事情发生了\n  4. 关心这个事件的人被通知\n  5. 拿到信息的人根据事件参数对事件进行处理\n\n## 小结\n\n事件是用来对象或者类之间的信息传递与动作协调。\n\n**事件 = 事件的通知 + 可选的事件的参数（详细信息）**\n\n## 事件的应用\n\n一个简单的小示例\n\n<pre><code class=\"csharp\">using System;\nusing System.Timers;\nnamespace Hanoi\n{\n \n    class Programme\n    {\n        static void Main(string[] args)\n        {\n            Timer timer = new Timer();//事件的发送者\n            timer.Interval = 1000;\n            Boy boy = new Boy();//事件的响应者\n            Gril gril = new Gril();\n            timer.Elapsed += gril.Action;\n            timer.Elapsed += boy.Action;//事件的订阅\n            timer.Start();\n            Console.ReadLine();\n        }\n    }\n \n    class Boy\n    {\n        internal void Action(object sender, ElapsedEventArgs e)//为了保持一致性,这里的定义是visual studio自动生成的\n        {\n            Console.WriteLine(\"Jump!!\");//事件处理器\n        }\n    }\n \n    class Gril\n    {\n        internal void Action(object sender, ElapsedEventArgs e)\n        {\n            Console.WriteLine(\"Song!\");\n        }\n    }\n \n}\n</code></pre>\n\n# 类型一:\n\n![](./C-事件详解/event.jpg)\n\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n{\n \n    class Programme\n    {\n        static void Main(string[] args)\n        {\n            Form form = new Form();\n            Recevier rev = new Recevier(form);\n            form.ShowDialog();\n        }\n    }\n \n    class Recevier\n    {\n        private Form form;\n        public Recevier(Form from)\n        {\n            if(from != null) \n            {\n                this.form = from;\n                this.form.Click += this.FormClicked;\n            }\n        }\n \n        private void FormClicked(object sender, EventArgs e)\n        {\n            this.form.Text = DateTime.Now.ToString();\n        }\n    }\n   \n \n}\n</code></pre>\n\n# 类型二:\n\n![](./C-事件详解/事件2.jpg)\n\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n{\n \n    class Programme\n    {\n        static void Main(string[] args)\n        {\n           MyForm form = new MyForm();\n           form.Click+=form.Action;\n            form.ShowDialog();\n        }\n    }\n    class MyForm : Form\n    {\n        internal void Action(object sender, EventArgs e)\n        {\n            this.Text = DateTime.Now.ToString();\n        }\n    }\n \n \n}\n</code></pre>\n\n# 类型三:\n\n![](./C-事件详解/事件三.jpg)\n\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n{\n \n    class Programme\n    {\n        static void Main(string[] args)\n        {\n            MyForm form = new MyForm(); \n            form.ShowDialog();\n        }\n    }\n \n    class MyForm:Form\n    {\n        private TextBox mytextbox;\n        private Button mybutton;\n        public MyForm()\n        {\n            mytextbox = new TextBox();\n            mybutton = new Button();\n            this.Controls.Add(mytextbox);\n            this.Controls.Add(mybutton);\n            mybutton.Height = 50;\n            mybutton.Left = 100;\n            mybutton.Top = 50;\n            mytextbox.Left = 100;\n            mybutton.Click+=this.Action;\n        }\n \n        private void Action(object sender, EventArgs e)\n        {\n            this.mytextbox.Text = \"Hello,World\";\n        }\n    }\n}\n</code></pre>\n\n# 制作自己的事件\n\n## 事件声明的完整格式\n\n可能会有一点点绕，但只要和委托事件结合起来，还是比较容易理解的。\n\n<pre><code class=\"csharp\">using System;\nusing System.Globalization;\nusing System.Windows.Forms;\nusing System.Threading;\nnamespace Hanoi\n{\n    class Programme\n    {\n        static void Main(string[] args)\n        {\n            Customer customer = new Customer();\n            Waiter waiter = new Waiter();\n            customer.Order += waiter.Action;//事件连接\n            customer.Action();\n        }\n    }\n \n \n    public class OrderArgs\n    {\n        public string Size { get; set; }\n        public string Name { get; set; }\n    }\n \n    public delegate void OrderHandller(Customer customer, OrderArgs e);\n    public class Customer\n    {\n        public int Bill { get; set; }\n        public void PaytheBill()\n        {\n            Console.WriteLine(\"I Will pay you {0} dollers\", Bill);\n        }\n        public OrderHandller orderHandller;\n        public event OrderHandller Order\n        {\n            add { orderHandller = value; }\n            remove { orderHandller = value; }\n        }\n        public void Action()\n        {\n            Console.WriteLine(\"Walking Into the resturant\");\n            for(int i=0;i<3;i++)\n            {\n                Console.WriteLine(\"da da da\");\n                Thread.Sleep(1000);\n            }\n            Console.WriteLine(\"Thinking .....\");\n            for(int i=0;i<3;i++)\n                Thread.Sleep(1000);\n            if(orderHandller != null)//这里是指事件发生了,有没有人响应\n            {\n                this.orderHandller(this, new OrderArgs() { Name = \"Pizza\", Size = \"large\" });\n            }\n        }\n \n    }\n    class Waiter\n    {\n        internal void Action(Customer customer, OrderArgs e)\n        {\n            switch(e.Size)\n            {\n                case \"large\":\n                    customer.Bill += 10;\n                    break;\n                case \"small\":\n                    customer.Bill += 5;\n                    break;\n                default:\n                    break;\n            }\n            Console.WriteLine(\"you shoud Pay{0} for the{1}\",customer.Bill, e.Name);\n            customer.PaytheBill();\n        }\n    }\n \n}\n</code></pre>\n\n## 事件声明简化版本\n\n<pre><code class=\"csharp\"> public OrderHandller orderHandller;\n public event OrderHandller Order\n {\n     add { orderHandller = value; }\n     remove { orderHandller = value; }\n }\n \nif(orderHandller!= null)//这里是指事件发生了,有没有人响应\n{\n    this.orderHandller(this, new OrderArgs() { Name = \"Pizza\", Size = \"large\" });\n}\n \n//将上述代码替换成\n public OrderHandller orderHandller;\npublic event OrderHandller Order;\n \nif(Order != null)//这里是指事件发生了,有没有人响应\n{\n    this.Order(this, new OrderArgs() { Name = \"Pizza\", Size = \"large\" });\n}\n</code></pre>\n\n## 用 C#自带的事件处理器处理事件\n\n<pre><code class=\"csharp\">using System;\nusing System.Globalization;\nusing System.Windows.Forms;\nusing System.Threading;\nnamespace Hanoi\n{\n    class Programme\n    {\n        static void Main(string[] args)\n        {\n            Customer customer = new Customer();\n            Waiter waiter = new Waiter();\n            customer.Order += waiter.Action;//事件连接\n            customer.Action();\n        }\n    }\n \n \n    public class OrderArgs:EventArgs\n    {\n        public string Size { get; set; }\n        public string Name { get; set; }\n    }\n    public class Customer\n    {\n        public int Bill { get; set; }\n        public void PaytheBill()\n        {\n            Console.WriteLine(\"I Will pay you {0} dollers\", Bill);\n        }\n        public event EventHandler Order;\n        public void Action()\n        {\n            Console.WriteLine(\"Walking Into the resturant\");\n            for(int i=0;i<3;i++)\n            {\n                Console.WriteLine(\"da da da\");\n                Thread.Sleep(1000);\n            }\n            Console.WriteLine(\"Thinking .....\");\n            for(int i=0;i<3;i++)\n                Thread.Sleep(1000);\n            if(Order != null)//这里是指事件发生了,有没有人响应\n            {\n                this.Order(this, new OrderArgs() { Name = \"Pizza\", Size = \"large\" });\n            }\n        }\n \n    }\n    class Waiter\n    {\n        internal void Action(object customer, EventArgs e)\n        {\n            Customer cus = customer as Customer;\n            OrderArgs args = e as OrderArgs;\n            switch(args.Size)\n            {\n                case \"large\":\n                    cus.Bill += 10;\n                    break;\n                case \"small\":\n                    cus.Bill += 5;\n                    break;\n                default:\n                    break;\n            }\n            Console.WriteLine(\"you shoud Pay{0} for the{1}\",cus.Bill, args.Name);\n            cus.PaytheBill();\n        }\n    }\n \n}\n</code></pre>\n\n事件的书写规范\n\n<pre><code class=\"csharp\">protected void OnOrder(object customer,OrderArgs args)\n{\n    if (Order != null)//这里是指事件发生了,有没有人响应\n    {\n        this.Order(customer, new OrderArgs() { Name = \"Pizza\", Size = \"large\" });\n    }\n}\n//事件的专属触发器用On+动词命名\n</code></pre>\n\n## 小结\n\n通过上述例子也可以得知,事件就是委托类型的包装器,包装器对委托的字段起到了限制的作用,也就是委托的参数只能由事件发起者自己来传递,而不由别人传递\n","slug":"C-事件详解","published":1,"updated":"2024-09-29T00:25:08.555Z","comments":1,"layout":"post","photos":[],"_id":"cm1muoetp0000sc7qfqhmh31m","content":"<p>关于 C#事件解析</p>\n<span id=\"more\"></span>\n\n<h1 id=\"一-什么是事件\"><a href=\"#一-什么是事件\" class=\"headerlink\" title=\"一. 什么是事件\"></a>一. 什么是事件</h1><h2 id=\"1-字面说明\"><a href=\"#1-字面说明\" class=\"headerlink\" title=\"1. 字面说明\"></a>1. 字面说明</h2><p>事件(Event): 通俗的解释就是“能够发生的事情”，并且事件都是隶属于某一个主体的，比如公司上市，那个上市这个事件就是隶属于公司。</p>\n<p>由上面的定义就可以知道，将事件抽象到代码当中就是，事件要隶属于一个类，也就是一个类的成员。</p>\n<p>在前面就已经讲过:</p>\n<ul>\n<li><strong>属性</strong>：让对象有了访问数据的功能</li>\n<li><strong>方法</strong>：让对象有了对数据加工的功能</li>\n<li><strong>事件</strong>：让对象有了通知能力，使对象有了能通风报信的成员</li>\n</ul>\n<h2 id=\"2-举个例子\"><a href=\"#2-举个例子\" class=\"headerlink\" title=\"2. 举个例子\"></a>2. 举个例子</h2><ul>\n<li><strong>手机</strong>：具备时间的对象</li>\n<li><strong>人</strong>：接受事件的对象，思考的过程就是事件处理器<br><img src=\"/2024/09/29/C-%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/event.jpg\"></li>\n</ul>\n<h1 id=\"总的来说\"><a href=\"#总的来说\" class=\"headerlink\" title=\"总的来说\"></a>总的来说</h1><p>根据事件参数来响应事件。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>事件模型的两个“5”：</p>\n<ul>\n<li><strong>“发生-&gt;响应”的五个部分</strong>：<ul>\n<li>“孩子 饿了 我 做饭”</li>\n<li>“闹钟 响了 我 上班”</li>\n</ul>\n</li>\n</ul>\n<p>其中的第五个部分存在订阅关系：“这个孩子是由我来响应的”，“这个闹钟是我的”。也就是说由绑定的关系，这样一来就是五个部分了。</p>\n<ul>\n<li><strong>“发生-&gt;响应”的五个动作</strong>：<ol>\n<li>有一个事件</li>\n<li>有一群人关注到这个事件</li>\n<li>事情发生了</li>\n<li>关心这个事件的人被通知</li>\n<li>拿到信息的人根据事件参数对事件进行处理</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>事件是用来对象或者类之间的信息传递与动作协调。</p>\n<p><strong>事件 &#x3D; 事件的通知 + 可选的事件的参数（详细信息）</strong></p>\n<h2 id=\"事件的应用\"><a href=\"#事件的应用\" class=\"headerlink\" title=\"事件的应用\"></a>事件的应用</h2><p>一个简单的小示例</p>\n<pre><code class=\"csharp\">using System;\nusing System.Timers;\nnamespace Hanoi\n&#123;\n \n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            Timer timer = new Timer();//事件的发送者\n            timer.Interval = 1000;\n            Boy boy = new Boy();//事件的响应者\n            Gril gril = new Gril();\n            timer.Elapsed += gril.Action;\n            timer.Elapsed += boy.Action;//事件的订阅\n            timer.Start();\n            Console.ReadLine();\n        &#125;\n    &#125;\n \n    class Boy\n    &#123;\n        internal void Action(object sender, ElapsedEventArgs e)//为了保持一致性,这里的定义是visual studio自动生成的\n        &#123;\n            Console.WriteLine(\"Jump!!\");//事件处理器\n        &#125;\n    &#125;\n \n    class Gril\n    &#123;\n        internal void Action(object sender, ElapsedEventArgs e)\n        &#123;\n            Console.WriteLine(\"Song!\");\n        &#125;\n    &#125;\n \n&#125;\n</code></pre>\n\n<h1 id=\"类型一\"><a href=\"#类型一\" class=\"headerlink\" title=\"类型一:\"></a>类型一:</h1><p><img src=\"/2024/09/29/C-%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/event.jpg\"></p>\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n&#123;\n \n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            Form form = new Form();\n            Recevier rev = new Recevier(form);\n            form.ShowDialog();\n        &#125;\n    &#125;\n \n    class Recevier\n    &#123;\n        private Form form;\n        public Recevier(Form from)\n        &#123;\n            if(from != null) \n            &#123;\n                this.form = from;\n                this.form.Click += this.FormClicked;\n            &#125;\n        &#125;\n \n        private void FormClicked(object sender, EventArgs e)\n        &#123;\n            this.form.Text = DateTime.Now.ToString();\n        &#125;\n    &#125;\n   \n \n&#125;\n</code></pre>\n\n<h1 id=\"类型二\"><a href=\"#类型二\" class=\"headerlink\" title=\"类型二:\"></a>类型二:</h1><p><img src=\"/2024/09/29/C-%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/%E4%BA%8B%E4%BB%B62.jpg\"></p>\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n&#123;\n \n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n           MyForm form = new MyForm();\n           form.Click+=form.Action;\n            form.ShowDialog();\n        &#125;\n    &#125;\n    class MyForm : Form\n    &#123;\n        internal void Action(object sender, EventArgs e)\n        &#123;\n            this.Text = DateTime.Now.ToString();\n        &#125;\n    &#125;\n \n \n&#125;\n</code></pre>\n\n<h1 id=\"类型三\"><a href=\"#类型三\" class=\"headerlink\" title=\"类型三:\"></a>类型三:</h1><p><img src=\"/2024/09/29/C-%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/%E4%BA%8B%E4%BB%B6%E4%B8%89.jpg\"></p>\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n&#123;\n \n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            MyForm form = new MyForm(); \n            form.ShowDialog();\n        &#125;\n    &#125;\n \n    class MyForm:Form\n    &#123;\n        private TextBox mytextbox;\n        private Button mybutton;\n        public MyForm()\n        &#123;\n            mytextbox = new TextBox();\n            mybutton = new Button();\n            this.Controls.Add(mytextbox);\n            this.Controls.Add(mybutton);\n            mybutton.Height = 50;\n            mybutton.Left = 100;\n            mybutton.Top = 50;\n            mytextbox.Left = 100;\n            mybutton.Click+=this.Action;\n        &#125;\n \n        private void Action(object sender, EventArgs e)\n        &#123;\n            this.mytextbox.Text = \"Hello,World\";\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<h1 id=\"制作自己的事件\"><a href=\"#制作自己的事件\" class=\"headerlink\" title=\"制作自己的事件\"></a>制作自己的事件</h1><h2 id=\"事件声明的完整格式\"><a href=\"#事件声明的完整格式\" class=\"headerlink\" title=\"事件声明的完整格式\"></a>事件声明的完整格式</h2><p>可能会有一点点绕，但只要和委托事件结合起来，还是比较容易理解的。</p>\n<pre><code class=\"csharp\">using System;\nusing System.Globalization;\nusing System.Windows.Forms;\nusing System.Threading;\nnamespace Hanoi\n&#123;\n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            Customer customer = new Customer();\n            Waiter waiter = new Waiter();\n            customer.Order += waiter.Action;//事件连接\n            customer.Action();\n        &#125;\n    &#125;\n \n \n    public class OrderArgs\n    &#123;\n        public string Size &#123; get; set; &#125;\n        public string Name &#123; get; set; &#125;\n    &#125;\n \n    public delegate void OrderHandller(Customer customer, OrderArgs e);\n    public class Customer\n    &#123;\n        public int Bill &#123; get; set; &#125;\n        public void PaytheBill()\n        &#123;\n            Console.WriteLine(\"I Will pay you &#123;0&#125; dollers\", Bill);\n        &#125;\n        public OrderHandller orderHandller;\n        public event OrderHandller Order\n        &#123;\n            add &#123; orderHandller = value; &#125;\n            remove &#123; orderHandller = value; &#125;\n        &#125;\n        public void Action()\n        &#123;\n            Console.WriteLine(\"Walking Into the resturant\");\n            for(int i=0;i<3;i++) &#123; console.writeline(\"da da da\"); thread.sleep(1000); &#125; console.writeline(\"thinking .....\"); for(int i=\"0;i<3;i++)\" if(orderhandller !=\"null)//这里是指事件发生了,有没有人响应\" this.orderhandller(this, new orderargs() name=\"Pizza\" , size=\"large\" &#125;); class waiter internal void action(customer customer, orderargs e) switch(e.size) case \"large\": customer.bill +=\"10;\" break; \"small\": default: console.writeline(\"you shoud pay&#123;0&#125; for the&#123;1&#125;\",customer.bill, e.name); customer.paythebill(); < code></3;i++)></code></pre>\n\n<h2 id=\"事件声明简化版本\"><a href=\"#事件声明简化版本\" class=\"headerlink\" title=\"事件声明简化版本\"></a>事件声明简化版本</h2><pre><code class=\"csharp\"> public OrderHandller orderHandller;\n public event OrderHandller Order\n &#123;\n     add &#123; orderHandller = value; &#125;\n     remove &#123; orderHandller = value; &#125;\n &#125;\n \nif(orderHandller!= null)//这里是指事件发生了,有没有人响应\n&#123;\n    this.orderHandller(this, new OrderArgs() &#123; Name = \"Pizza\", Size = \"large\" &#125;);\n&#125;\n \n//将上述代码替换成\n public OrderHandller orderHandller;\npublic event OrderHandller Order;\n \nif(Order != null)//这里是指事件发生了,有没有人响应\n&#123;\n    this.Order(this, new OrderArgs() &#123; Name = \"Pizza\", Size = \"large\" &#125;);\n&#125;\n</code></pre>\n\n<h2 id=\"用-C-自带的事件处理器处理事件\"><a href=\"#用-C-自带的事件处理器处理事件\" class=\"headerlink\" title=\"用 C#自带的事件处理器处理事件\"></a>用 C#自带的事件处理器处理事件</h2><pre><code class=\"csharp\">using System;\nusing System.Globalization;\nusing System.Windows.Forms;\nusing System.Threading;\nnamespace Hanoi\n&#123;\n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            Customer customer = new Customer();\n            Waiter waiter = new Waiter();\n            customer.Order += waiter.Action;//事件连接\n            customer.Action();\n        &#125;\n    &#125;\n \n \n    public class OrderArgs:EventArgs\n    &#123;\n        public string Size &#123; get; set; &#125;\n        public string Name &#123; get; set; &#125;\n    &#125;\n    public class Customer\n    &#123;\n        public int Bill &#123; get; set; &#125;\n        public void PaytheBill()\n        &#123;\n            Console.WriteLine(\"I Will pay you &#123;0&#125; dollers\", Bill);\n        &#125;\n        public event EventHandler Order;\n        public void Action()\n        &#123;\n            Console.WriteLine(\"Walking Into the resturant\");\n            for(int i=0;i<3;i++) &#123; console.writeline(\"da da da\"); thread.sleep(1000); &#125; console.writeline(\"thinking .....\"); for(int i=\"0;i<3;i++)\" if(order !=\"null)//这里是指事件发生了,有没有人响应\" this.order(this, new orderargs() name=\"Pizza\" , size=\"large\" &#125;); class waiter internal void action(object customer, eventargs e) customer cus=\"customer\" as customer; orderargs args=\"e\" orderargs; switch(args.size) case \"large\": cus.bill +=\"10;\" break; \"small\": default: console.writeline(\"you shoud pay&#123;0&#125; for the&#123;1&#125;\",cus.bill, args.name); cus.paythebill(); < code></3;i++)></code></pre>\n\n<p>事件的书写规范</p>\n<pre><code class=\"csharp\">protected void OnOrder(object customer,OrderArgs args)\n&#123;\n    if (Order != null)//这里是指事件发生了,有没有人响应\n    &#123;\n        this.Order(customer, new OrderArgs() &#123; Name = \"Pizza\", Size = \"large\" &#125;);\n    &#125;\n&#125;\n//事件的专属触发器用On+动词命名\n</code></pre>\n\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>通过上述例子也可以得知,事件就是委托类型的包装器,包装器对委托的字段起到了限制的作用,也就是委托的参数只能由事件发起者自己来传递,而不由别人传递</p>\n","excerpt":"<p>关于 C#事件解析</p>","more":"<h1 id=\"一-什么是事件\"><a href=\"#一-什么是事件\" class=\"headerlink\" title=\"一. 什么是事件\"></a>一. 什么是事件</h1><h2 id=\"1-字面说明\"><a href=\"#1-字面说明\" class=\"headerlink\" title=\"1. 字面说明\"></a>1. 字面说明</h2><p>事件(Event): 通俗的解释就是“能够发生的事情”，并且事件都是隶属于某一个主体的，比如公司上市，那个上市这个事件就是隶属于公司。</p>\n<p>由上面的定义就可以知道，将事件抽象到代码当中就是，事件要隶属于一个类，也就是一个类的成员。</p>\n<p>在前面就已经讲过:</p>\n<ul>\n<li><strong>属性</strong>：让对象有了访问数据的功能</li>\n<li><strong>方法</strong>：让对象有了对数据加工的功能</li>\n<li><strong>事件</strong>：让对象有了通知能力，使对象有了能通风报信的成员</li>\n</ul>\n<h2 id=\"2-举个例子\"><a href=\"#2-举个例子\" class=\"headerlink\" title=\"2. 举个例子\"></a>2. 举个例子</h2><ul>\n<li><strong>手机</strong>：具备时间的对象</li>\n<li><strong>人</strong>：接受事件的对象，思考的过程就是事件处理器<br><img src=\"/2024/09/29/C-%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/event.jpg\"></li>\n</ul>\n<h1 id=\"总的来说\"><a href=\"#总的来说\" class=\"headerlink\" title=\"总的来说\"></a>总的来说</h1><p>根据事件参数来响应事件。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>事件模型的两个“5”：</p>\n<ul>\n<li><strong>“发生-&gt;响应”的五个部分</strong>：<ul>\n<li>“孩子 饿了 我 做饭”</li>\n<li>“闹钟 响了 我 上班”</li>\n</ul>\n</li>\n</ul>\n<p>其中的第五个部分存在订阅关系：“这个孩子是由我来响应的”，“这个闹钟是我的”。也就是说由绑定的关系，这样一来就是五个部分了。</p>\n<ul>\n<li><strong>“发生-&gt;响应”的五个动作</strong>：<ol>\n<li>有一个事件</li>\n<li>有一群人关注到这个事件</li>\n<li>事情发生了</li>\n<li>关心这个事件的人被通知</li>\n<li>拿到信息的人根据事件参数对事件进行处理</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>事件是用来对象或者类之间的信息传递与动作协调。</p>\n<p><strong>事件 &#x3D; 事件的通知 + 可选的事件的参数（详细信息）</strong></p>\n<h2 id=\"事件的应用\"><a href=\"#事件的应用\" class=\"headerlink\" title=\"事件的应用\"></a>事件的应用</h2><p>一个简单的小示例</p>\n<pre><code class=\"csharp\">using System;\nusing System.Timers;\nnamespace Hanoi\n&#123;\n \n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            Timer timer = new Timer();//事件的发送者\n            timer.Interval = 1000;\n            Boy boy = new Boy();//事件的响应者\n            Gril gril = new Gril();\n            timer.Elapsed += gril.Action;\n            timer.Elapsed += boy.Action;//事件的订阅\n            timer.Start();\n            Console.ReadLine();\n        &#125;\n    &#125;\n \n    class Boy\n    &#123;\n        internal void Action(object sender, ElapsedEventArgs e)//为了保持一致性,这里的定义是visual studio自动生成的\n        &#123;\n            Console.WriteLine(\"Jump!!\");//事件处理器\n        &#125;\n    &#125;\n \n    class Gril\n    &#123;\n        internal void Action(object sender, ElapsedEventArgs e)\n        &#123;\n            Console.WriteLine(\"Song!\");\n        &#125;\n    &#125;\n \n&#125;\n</code></pre>\n\n<h1 id=\"类型一\"><a href=\"#类型一\" class=\"headerlink\" title=\"类型一:\"></a>类型一:</h1><p><img src=\"/2024/09/29/C-%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/event.jpg\"></p>\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n&#123;\n \n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            Form form = new Form();\n            Recevier rev = new Recevier(form);\n            form.ShowDialog();\n        &#125;\n    &#125;\n \n    class Recevier\n    &#123;\n        private Form form;\n        public Recevier(Form from)\n        &#123;\n            if(from != null) \n            &#123;\n                this.form = from;\n                this.form.Click += this.FormClicked;\n            &#125;\n        &#125;\n \n        private void FormClicked(object sender, EventArgs e)\n        &#123;\n            this.form.Text = DateTime.Now.ToString();\n        &#125;\n    &#125;\n   \n \n&#125;\n</code></pre>\n\n<h1 id=\"类型二\"><a href=\"#类型二\" class=\"headerlink\" title=\"类型二:\"></a>类型二:</h1><p><img src=\"/2024/09/29/C-%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/%E4%BA%8B%E4%BB%B62.jpg\"></p>\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n&#123;\n \n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n           MyForm form = new MyForm();\n           form.Click+=form.Action;\n            form.ShowDialog();\n        &#125;\n    &#125;\n    class MyForm : Form\n    &#123;\n        internal void Action(object sender, EventArgs e)\n        &#123;\n            this.Text = DateTime.Now.ToString();\n        &#125;\n    &#125;\n \n \n&#125;\n</code></pre>\n\n<h1 id=\"类型三\"><a href=\"#类型三\" class=\"headerlink\" title=\"类型三:\"></a>类型三:</h1><p><img src=\"/2024/09/29/C-%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3/%E4%BA%8B%E4%BB%B6%E4%B8%89.jpg\"></p>\n<pre><code class=\"csharp\">using System;\nusing System.Windows.Forms;\nnamespace Hanoi\n&#123;\n \n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            MyForm form = new MyForm(); \n            form.ShowDialog();\n        &#125;\n    &#125;\n \n    class MyForm:Form\n    &#123;\n        private TextBox mytextbox;\n        private Button mybutton;\n        public MyForm()\n        &#123;\n            mytextbox = new TextBox();\n            mybutton = new Button();\n            this.Controls.Add(mytextbox);\n            this.Controls.Add(mybutton);\n            mybutton.Height = 50;\n            mybutton.Left = 100;\n            mybutton.Top = 50;\n            mytextbox.Left = 100;\n            mybutton.Click+=this.Action;\n        &#125;\n \n        private void Action(object sender, EventArgs e)\n        &#123;\n            this.mytextbox.Text = \"Hello,World\";\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<h1 id=\"制作自己的事件\"><a href=\"#制作自己的事件\" class=\"headerlink\" title=\"制作自己的事件\"></a>制作自己的事件</h1><h2 id=\"事件声明的完整格式\"><a href=\"#事件声明的完整格式\" class=\"headerlink\" title=\"事件声明的完整格式\"></a>事件声明的完整格式</h2><p>可能会有一点点绕，但只要和委托事件结合起来，还是比较容易理解的。</p>\n<pre><code class=\"csharp\">using System;\nusing System.Globalization;\nusing System.Windows.Forms;\nusing System.Threading;\nnamespace Hanoi\n&#123;\n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            Customer customer = new Customer();\n            Waiter waiter = new Waiter();\n            customer.Order += waiter.Action;//事件连接\n            customer.Action();\n        &#125;\n    &#125;\n \n \n    public class OrderArgs\n    &#123;\n        public string Size &#123; get; set; &#125;\n        public string Name &#123; get; set; &#125;\n    &#125;\n \n    public delegate void OrderHandller(Customer customer, OrderArgs e);\n    public class Customer\n    &#123;\n        public int Bill &#123; get; set; &#125;\n        public void PaytheBill()\n        &#123;\n            Console.WriteLine(\"I Will pay you &#123;0&#125; dollers\", Bill);\n        &#125;\n        public OrderHandller orderHandller;\n        public event OrderHandller Order\n        &#123;\n            add &#123; orderHandller = value; &#125;\n            remove &#123; orderHandller = value; &#125;\n        &#125;\n        public void Action()\n        &#123;\n            Console.WriteLine(\"Walking Into the resturant\");\n            for(int i=0;i<3;i++) &#123; console.writeline(\"da da da\"); thread.sleep(1000); &#125; console.writeline(\"thinking .....\"); for(int i=\"0;i<3;i++)\" if(orderhandller !=\"null)//这里是指事件发生了,有没有人响应\" this.orderhandller(this, new orderargs() name=\"Pizza\" , size=\"large\" &#125;); class waiter internal void action(customer customer, orderargs e) switch(e.size) case \"large\": customer.bill +=\"10;\" break; \"small\": default: console.writeline(\"you shoud pay&#123;0&#125; for the&#123;1&#125;\",customer.bill, e.name); customer.paythebill(); < code></3;i++)></code></pre>\n\n<h2 id=\"事件声明简化版本\"><a href=\"#事件声明简化版本\" class=\"headerlink\" title=\"事件声明简化版本\"></a>事件声明简化版本</h2><pre><code class=\"csharp\"> public OrderHandller orderHandller;\n public event OrderHandller Order\n &#123;\n     add &#123; orderHandller = value; &#125;\n     remove &#123; orderHandller = value; &#125;\n &#125;\n \nif(orderHandller!= null)//这里是指事件发生了,有没有人响应\n&#123;\n    this.orderHandller(this, new OrderArgs() &#123; Name = \"Pizza\", Size = \"large\" &#125;);\n&#125;\n \n//将上述代码替换成\n public OrderHandller orderHandller;\npublic event OrderHandller Order;\n \nif(Order != null)//这里是指事件发生了,有没有人响应\n&#123;\n    this.Order(this, new OrderArgs() &#123; Name = \"Pizza\", Size = \"large\" &#125;);\n&#125;\n</code></pre>\n\n<h2 id=\"用-C-自带的事件处理器处理事件\"><a href=\"#用-C-自带的事件处理器处理事件\" class=\"headerlink\" title=\"用 C#自带的事件处理器处理事件\"></a>用 C#自带的事件处理器处理事件</h2><pre><code class=\"csharp\">using System;\nusing System.Globalization;\nusing System.Windows.Forms;\nusing System.Threading;\nnamespace Hanoi\n&#123;\n    class Programme\n    &#123;\n        static void Main(string[] args)\n        &#123;\n            Customer customer = new Customer();\n            Waiter waiter = new Waiter();\n            customer.Order += waiter.Action;//事件连接\n            customer.Action();\n        &#125;\n    &#125;\n \n \n    public class OrderArgs:EventArgs\n    &#123;\n        public string Size &#123; get; set; &#125;\n        public string Name &#123; get; set; &#125;\n    &#125;\n    public class Customer\n    &#123;\n        public int Bill &#123; get; set; &#125;\n        public void PaytheBill()\n        &#123;\n            Console.WriteLine(\"I Will pay you &#123;0&#125; dollers\", Bill);\n        &#125;\n        public event EventHandler Order;\n        public void Action()\n        &#123;\n            Console.WriteLine(\"Walking Into the resturant\");\n            for(int i=0;i<3;i++) &#123; console.writeline(\"da da da\"); thread.sleep(1000); &#125; console.writeline(\"thinking .....\"); for(int i=\"0;i<3;i++)\" if(order !=\"null)//这里是指事件发生了,有没有人响应\" this.order(this, new orderargs() name=\"Pizza\" , size=\"large\" &#125;); class waiter internal void action(object customer, eventargs e) customer cus=\"customer\" as customer; orderargs args=\"e\" orderargs; switch(args.size) case \"large\": cus.bill +=\"10;\" break; \"small\": default: console.writeline(\"you shoud pay&#123;0&#125; for the&#123;1&#125;\",cus.bill, args.name); cus.paythebill(); < code></3;i++)></code></pre>\n\n<p>事件的书写规范</p>\n<pre><code class=\"csharp\">protected void OnOrder(object customer,OrderArgs args)\n&#123;\n    if (Order != null)//这里是指事件发生了,有没有人响应\n    &#123;\n        this.Order(customer, new OrderArgs() &#123; Name = \"Pizza\", Size = \"large\" &#125;);\n    &#125;\n&#125;\n//事件的专属触发器用On+动词命名\n</code></pre>\n\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>通过上述例子也可以得知,事件就是委托类型的包装器,包装器对委托的字段起到了限制的作用,也就是委托的参数只能由事件发起者自己来传递,而不由别人传递</p>"},{"title":"Foot IK","date":"2024-09-27T09:31:18.000Z","_content":"\n关于 Unity3d 中的反向动力学代码解读\n\n<!-- more -->\n\n# 认识 IK (Inverse Kinematics)\n\n在 Unity3D 中的人物动画中有十个位置的 IK，分别是：\n\n- 头部\n- 左右手掌\n- 左右脚掌\n- 左右膝关节\n- 左右手肘关节\n  ![](./Foot-IK/NO.01.001.jpg)\n\n# IK 理解与权重\n\n看到上面的那几个红球吗？这些球就是在 Unity 分析骨骼时生成的。根据其他 UP 的解释，这些球表示肢体本应该到达的位置。\n\n我的理解是，以脚部为例，要实现反向动力学必须有一个运动的趋势。如果脚掌抬高，膝盖应该怎么移动呢？对，就是向给定的 IK 位置移动。作为一个初学者，我认为这样的理解方法最适合我，后期我会慢慢学习并修缮我的理解。\n\n## IK 权重\n\nIK 权重比较好理解。人物最初的动画都是按照设计来的，所以权重为零，这样就不会受到 IK 的影响。相反，权重越高，那个部位就会越靠近 IK 的位置，权重范围在(0,1)之间。\n\n<div style=\"display:flex;\">\n  <img src=\"./Foot-IK/anbi1.jpg\" width=\"200\" />\n  <img src=\"./Foot-IK/anbi2.jpg\" width=\"200\" />\n  <img src=\"./Foot-IK/anbi3.jpg\" width=\"200\" />\n</div>\n\n# 脚踝 IK 观察与代码解读\n\n在上面的三个图中，我将脚踝上的 IK 放到前面方便观察：\n\n- **第一张图**：权重等于零的时候，可以看到动画还是按照原先的动画效果来。\n- **第二张图**：随着权重的增加，脚踝的位置就慢慢向 IK 的位置靠近。\n\n## IK 相关函数\n\nIK 相关函数大体上分为三类：\n\n1. **设置 IK 位置和旋转**：\n\n   - `setIKposition(enum, vector3)` 来设置 IK 的位置\n   - `setIKrotation(enum, Quaternions)` 来设置旋转\n\n2. **设置权重**：\n   - `setIkweight(enum, float(0-1))` 来设置权重\n\n## 解读脚部 IK 代码\n\n<pre><code class=\"csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n \n[RequireComponent(typeof(Animator))]\npublic class IKSetting : MonoBehaviour\n{\n    public bool enableFeetIk = true; //是否开启ik\n    [Range(0, 2)] [SerializeField] private float heightFromGroundRaycast = 1.2f; //从地面向上的cast距离\n    [Range(0, 2)] [SerializeField] private float raycastDownDistance = 1.5f; //向下cast 距离\n    [SerializeField] private LayerMask environmentLayer; //检测layer\n    [SerializeField] private float pelvisOffset = 0f; //盆骨offset\n    [Range(0, 1)] [SerializeField] private float pelvisUpAndDownSpeed = 0.28f; //盆骨赋值速度\n    [Range(0, 1)] [SerializeField] private float feetToIkPositionSpeed = 0.5f; //足IK赋值速度\n    public string leftFootAnimCurveName = \"LeftFoot\"; //权重曲线名称\n    public string rightFootAnimCurveName = \"RightFoot\"; //权重曲线名称\n    [Range(0, 100)] public float leftFootAngleOffset; //旋转偏移\n    [Range(0, 100)] public float rightFootAngleOffset; //旋转偏移\n    public bool useIkFeature = false; //是否使用IK旋转\n \n    public bool showSolverDebug = true;// Debug绘制\n \n    private Animator m_animator; //动画机\n \n    private Vector3 _rightFootPosition, _leftFootPosition; //足部骨骼posiition\n    private Vector3 _rightFootIkPosition, _leftFootIkPosition; //足部IK position\n    private Quaternion _leftFootIkRotation, _rightFootIkRotation; //足部IK rotation\n    private float _lastPelvisPositionY, _lastRightFootPositionY, _lastLeftFootPositionY; //上帧信息，用于lerp动画\n \n    #region for Gizmos\n    private Vector3 rightHitPoint;\n    private Vector3 leftHitPoint;\n    private bool flip = false;\n    #endregion\n \n    private void Start()\n    {\n        m_animator = GetComponent<Animator>();\n    }\n \n    private void FixedUpdate()\n    {\n        if (!enableFeetIk) return;\n        if (!m_animator) return;\n \n        \n        AdjustFeetTarget(ref _rightFootPosition, HumanBodyBones.RightFoot); //设置 足部骨骼posiition\n        AdjustFeetTarget(ref _leftFootPosition, HumanBodyBones.LeftFoot); // 设置 足部骨骼posiition\n \n        FootPositionSolver(_rightFootPosition, ref _rightFootIkPosition, ref _rightFootIkRotation, rightFootAngleOffset); //IK 解算\n        FootPositionSolver(_leftFootPosition, ref _leftFootIkPosition, ref _leftFootIkRotation, leftFootAngleOffset);\n    }\n \n    private void OnAnimatorIK(int layerIndex)\n    {\n        if (!enableFeetIk) return;\n        if (!m_animator) return;\n \n        MovePelvisHeight(); //骨盆偏移\n \n        m_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //保证行走的时候脚部脱离,不然会粘在地上\n        if (useIkFeature)\n        {\n            m_animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //设置 rot 权重\n        }\n        MoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY); //设置ik goal坐标\n \n        m_animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));\n        if (useIkFeature)\n        {\n            m_animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));\n        }\n        MoveFeetToIkPoint(AvatarIKGoal.LeftFoot, _leftFootIkPosition, _leftFootIkRotation, ref _lastLeftFootPositionY);\n    }\n \n    void MoveFeetToIkPoint(AvatarIKGoal foot, Vector3 positionIkHolder, Quaternion rotationIkHolder, ref float lastFootPositionY)\n    {\n        Vector3 targetIkPosition = m_animator.GetIKPosition(foot); //获得红色圆球的位置\n \n        if (positionIkHolder != Vector3.zero) //如果新的IK pos 不为 0 \n        {\n            targetIkPosition = transform.InverseTransformPoint(targetIkPosition); //把原本的ik goal 的pos转换到本地坐标系\n            positionIkHolder = transform.InverseTransformPoint(positionIkHolder); //把现在的ik goal 的pos转到本地坐标系\n \n            float yVar = Mathf.Lerp(lastFootPositionY, positionIkHolder.y, feetToIkPositionSpeed); //进行插值\n            targetIkPosition.y += yVar;\n            lastFootPositionY = yVar;\n \n            targetIkPosition = transform.TransformPoint(targetIkPosition); //把新的ik goal pos转到世界坐标系\n \n            m_animator.SetIKRotation(foot, rotationIkHolder); //旋转赋予\n        }\n        m_animator.SetIKPosition(foot, targetIkPosition); //位置赋予\n    }\n \n    void MovePelvisHeight() //调整pelvis，保证IK 能达到（比如左右脚高度差那种）\n    {\n        if (_rightFootIkPosition == Vector3.zero || _leftFootIkPosition == Vector3.zero || _lastPelvisPositionY == 0f)\n        {\n            _lastPelvisPositionY = m_animator.bodyPosition.y;\n            return;\n        }\n \n        float lOffsetPosition = _leftFootIkPosition.y - transform.position.y; //左脚ik pos与当前transform的高度差\n        float rOffsetPosition = _rightFootIkPosition.y - transform.position.y; //右脚ik pos 与当前transform的高度差\n \n        //选择较小值（在以vector3.up为正轴的情况下）\n        //如果是正值，则向上偏移距离较小的。\n        //如果是负值，则向下偏移距离较大的。\n        float totalOffset = (lOffsetPosition < rOffsetPosition) ? lOffsetPosition : rOffsetPosition;\n \n        Vector3 newPelvisPosition = m_animator.bodyPosition + Vector3.up * totalOffset; //新的骨盆位置计算： 原位置+ up方向 * offset。\n        newPelvisPosition.y = Mathf.Lerp(_lastPelvisPositionY, newPelvisPosition.y, pelvisUpAndDownSpeed); //插值动画\n        m_animator.bodyPosition = newPelvisPosition; //赋值\n        _lastPelvisPositionY = m_animator.bodyPosition.y; //记录信息\n    }\n \n    void FootPositionSolver(Vector3 fromSkyPosition, ref Vector3 feetIkPosition, ref Quaternion feetIkRotation, float angleOffset)\n    {\n        if (showSolverDebug)\n        {\n            Debug.DrawLine(fromSkyPosition, fromSkyPosition + Vector3.down * (raycastDownDistance), Color.green);\n            Debug.Log(\"fromskyposition:\"+fromSkyPosition);\n        }\n \n        if (Physics.Raycast(fromSkyPosition, Vector3.down, out var feetOutHit, raycastDownDistance+ heightFromGroundRaycast, environmentLayer))\n        {\n            feetIkPosition = fromSkyPosition; //保存x,z值。\n            feetIkPosition.y = feetOutHit.point.y + pelvisOffset; //hit pos 的 Y 赋值\n \n            feetIkRotation = Quaternion.FromToRotation(Vector3.up, feetOutHit.normal) * transform.rotation; //计算法向偏移\n            feetIkRotation = Quaternion.AngleAxis(angleOffset, Vector3.up) * feetIkRotation; //计算额外的偏移\n \n            return;\n        }\n        feetIkPosition = Vector3.zero; //没有hit，归零\n    }\n \n    void AdjustFeetTarget(ref Vector3 feetPosition, HumanBodyBones foot)\n    {\n        \n        feetPosition = m_animator.GetBoneTransform(foot).position; //获取人形足部的transform position\n        feetPosition.y = transform.position.y + heightFromGroundRaycast; //y的值会加上【向上检测的距离】，主要是防止卡模型。\n       \n    }\n    private void OnDrawGizmos()\n    {\n        Gizmos.DrawSphere(rightHitPoint, 1.0f);\n        Gizmos.DrawSphere(leftHitPoint, 0.01f);\n    }\n}\n</code></pre>\n\n看到上面代码的你肯定是一脸懵逼 ,下面就让我来一一解读、\n\n<pre><code class=\"csharp\">[RequireComponent(typeof(Animator))]\n</code></pre>\n\n这个提一嘴免得有人还不知道,所挂载的物体上必须要有一个 Animator 组件\n\n<pre><code class=\"csharp\">\npublic bool enableFeetIk = true; //是否开启ik  \n[Range(0, 2)] [SerializeField] private float heightFromGroundRaycast = 1.2f; //从地面向上的cast距离  \n[Range(0, 2)] [SerializeField] private float raycastDownDistance = 1.5f; //向下cast 距离  \n[SerializeField] private LayerMask environmentLayer; //检测layer  \n[SerializeField] private float pelvisOffset = 0f; //盆骨offset  \n[Range(0, 1)] [SerializeField] private float pelvisUpAndDownSpeed = 0.28f; //盆骨赋值速度  \n[Range(0, 1)] [SerializeField] private float feetToIkPositionSpeed = 0.5f; //足IK赋值速度  \npublic string leftFootAnimCurveName = \"LeftFoot\"; //权重曲线名称  \npublic string rightFootAnimCurveName = \"RightFoot\"; //权重曲线名称  \n[Range(0, 100)] public float leftFootAngleOffset; //旋转偏移  \n[Range(0, 100)] public float rightFootAngleOffset; //旋转偏移  \npublic bool useIkFeature = false; //是否使用IK旋转  \n\npublic bool showSolverDebug = true;// Debug绘制  \n\nprivate Animator m_animator; //动画机  \n\nprivate Vector3 _rightFootPosition, _leftFootPosition; //足部骨骼posiition  \nprivate Vector3 _rightFootIkPosition, _leftFootIkPosition; //足部IK position  \nprivate Quaternion _leftFootIkRotation, _rightFootIkRotation; //足部IK rotation  \nprivate float _lastPelvisPositionY, _lastRightFootPositionY, _lastLeftFootPositionY; //上帧信息，用于lerp动画  \n\n#region for Gizmos  \nprivate Vector3 rightHitPoint;  \nprivate Vector3 leftHitPoint;  \nprivate bool flip = false;  \n#endregion  \n\nprivate void Start()  \n{  \n    m_animator = GetComponent<Animator>();  \n}\n</code></pre>\n\n这一块代码首先说明一下这个\n\n<pre><code class=\"csharp\">[Range(0, 2)] [SerializeField]  \n</code></pre>\n\n这个就是表明在 unity3d 编辑器界面的范围,而第二个就是表示可以序列化(说人话就是即使是 private 也可以被修改)\n\n其他的看看注释就行了\n\n<pre><code class=\"csharp\">#region for Gizmos  \nprivate Vector3 rightHitPoint;  \nprivate Vector3 leftHitPoint;  \nprivate bool flip = false;\n</code></pre>\n\n这段代码应该是在 unity3d 界面上画的,和具体功能无关,只是想画出接触点的位置不必理会\n\n来看看 void fixedupdate 里面的 AdjustFeetTarget 这个函数其函数定义如下\n\n<pre><code class=\"csharp\">void AdjustFeetTarget(ref Vector3 feetPosition, HumanBodyBones foot)  \n{  \n    feetPosition = m_animator.GetBoneTransform(foot).position; //获取人形足部的transform position  \n    feetPosition.y = transform.position.y + heightFromGroundRaycast; //y的值会加上【向上检测的距离】，主要是防止卡模型。  \n}\n</code></pre>\n\n这个函数的作用就是时时刻刻计算出检测点发射的位置,并且通过 ref feetposition 回调,方便下面的检测碰撞体使用,下面就来看看 FootPositionSolver 这个函数\n\n<pre><code class=\"csharp\">\nvoid FootPositionSolver(Vector3 fromSkyPosition, ref Vector3 feetIkPosition, ref Quaternion feetIkRotation, float angleOffset)  \n{  \n    if (showSolverDebug)  \n    {  \n        Debug.DrawLine(fromSkyPosition, fromSkyPosition + Vector3.down * (raycastDownDistance), Color.green);  \n        Debug.Log(\"fromskyposition:\"+fromSkyPosition);  \n    }  \n\n    if (Physics.Raycast(fromSkyPosition, Vector3.down, out var feetOutHit, raycastDownDistance+ heightFromGroundRaycast, environmentLayer))  \n    {  \n        feetIkPosition = fromSkyPosition; //保存x,z值。  \n        feetIkPosition.y = feetOutHit.point.y + pelvisOffset; //hit pos 的 Y 赋值  \n\n        feetIkRotation = Quaternion.FromToRotation(Vector3.up, feetOutHit.normal) * transform.rotation; //计算法向偏移  \n        feetIkRotation = Quaternion.AngleAxis(angleOffset, Vector3.up) * feetIkRotation; //计算额外的偏移  \n\n        return;  \n    }  \n    feetIkPosition = Vector3.zero; //没有hit，归零  \n}\n</code></pre>\n\n第一个 if 语句就是要不要绘制那条检测射线\n\n然后第二个判断语句就是检测碰撞体,也十分容易理解\n\nFromToRotation 函数计算从 Vector3.up 到 feetOutHit.normal 的旋转，这样就可以使角色的脚与地面的法线方向对齐,四元数我现在还没开始学所以只能记住用法了\n\nfeetIkRotation = Quaternion.AngleAxis(angleOffset, Vector3.up) \\* feetIkRotation; //计算额外的偏移这个也是一样就是脚掌的向内外偏移\n\n最后就得到了脚掌的 IK 了\n\n相反如果没有碰撞体的话就返回零,注意这里没有碰撞体是指悬浮在空中,不是站在地面上,因为站在地面上的碰撞体就是地面\n\n接下来就是 private void OnAnimatorIK(int layerIndex),这个函数只有在动画设置了 IK pass 的时候才能调用,并且也只能在这里设置 IK 相应的函数\n\n<pre><code class=\"csharp\">\nprivate void OnAnimatorIK(int layerIndex)  \n{  \n    if (!enableFeetIk) return;  \n    if (!m_animator) return;  \n\n    MovePelvisHeight(); //骨盆偏移  \n\n    m_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //保证行走的时候脚部脱离,不然会粘在地上  \n    if (useIkFeature)  \n    {  \n        m_animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //设置 rot 权重  \n    }  \n    MoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY); //设置ik goal坐标  \n\n    m_animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));  \n    if (useIkFeature)  \n    {  \n        m_animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));  \n    }  \n    MoveFeetToIkPoint(AvatarIKGoal.LeftFoot, _leftFootIkPosition, _leftFootIkRotation, ref _lastLeftFootPositionY);  \n}\n</code></pre>\n\n前面两个语句就是防止报错写的不必多想\n\n我们先说简单的\n\n<pre><code class=\"csharp\">\nm_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName));  \n</code></pre>\n\n这个就是根据动画曲线来设置权重,为什么要这样做捏,因为在人物跑步的时候总不能设置权重为 1 吧,这样就好像人的脚被锁住了,所以这里通过设置动画曲线的形式在和权重联动\n\n接下来稍微需要一点思考的\n\n<pre><code class=\"csharp\">\nMoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY);  \n</code></pre>\n\n<pre><code class=\"csharp\">\nvoid MoveFeetToIkPoint(AvatarIKGoal foot, Vector3 positionIkHolder, Quaternion rotationIkHolder, ref float lastFootPositionY)  \n{  \n    Vector3 targetIkPosition = m_animator.GetIKPosition(foot); //获得红色圆球的位置  \n\n    if (positionIkHolder != Vector3.zero) //如果新的IK pos 不为 0   \n    {  \n        targetIkPosition = transform.InverseTransformPoint(targetIkPosition); //把原本的ik goal 的pos转换到本地坐标系  \n        positionIkHolder = transform.InverseTransformPoint(positionIkHolder); //把现在的ik goal 的pos转到本地坐标系  \n\n        float yVar = Mathf.Lerp(lastFootPositionY, positionIkHolder.y, feetToIkPositionSpeed); //进行插值  \n        targetIkPosition.y += yVar;  \n        lastFootPositionY = yVar;  \n\n        targetIkPosition = transform.TransformPoint(targetIkPosition); //把新的ik goal pos转到世界坐标系  \n\n        m_animator.SetIKRotation(foot, rotationIkHolder); //旋转赋予  \n    }  \n    m_animator.SetIKPosition(foot, targetIkPosition); //位置赋予  \n}\n</code></pre>\n\n刚刚说过了如果 IK 等于零的话不就是飞在天上了嘛,所以这种情况就不用判断了  \n这个代码的解决方案就是先将脚踝的 IK(已经经过上面的计算得到了结果)转化成相对于父物体的本地坐标,下面的也是一样\n\n奇怪的东西就来了你一定会注意到 lastFootPositionY 这个东西在哪里用过,然后按住 Ctrl 点击这个发现只有这里用了,其实这个是因为脚部的初始位置本来就是零,所以这里就直接按照默认值来了,然后又出现了新的问题,就是这个\"+=\"为什么不是\"=\"呢，因为这个是本地坐标也就是脚掌到 IK 原本的距离,然后通过计算从脚踝到碰撞面的距离进行插值这样就可以实现脚部 IK 了\n\n最后再来介绍一下\n\n<pre><code class=\"csharp\">\nvoid MovePelvisHeight() //调整pelvis，保证IK 能达到（比如左右脚高度差那种）  \n{  \n    if (_rightFootIkPosition == Vector3.zero || _leftFootIkPosition == Vector3.zero || _lastPelvisPositionY == 0f)  \n    {  \n        _lastPelvisPositionY = m_animator.bodyPosition.y;  \n        return;  \n    }  \n\n    float lOffsetPosition = _leftFootIkPosition.y - transform.position.y; //左脚ik pos与当前transform的高度差  \n    float rOffsetPosition = _rightFootIkPosition.y - transform.position.y; //右脚ik pos 与当前transform的高度差  \n\n    //选择较小值（在以vector3.up为正轴的情况下）  \n    //如果是正值，则向上偏移距离较小的。  \n    //如果是负值，则向下偏移距离较大的。  \n    float totalOffset = (lOffsetPosition < rOffsetPosition) ? lOffsetPosition : rOffsetPosition;  \n\n    Vector3 newPelvisPosition = m_animator.bodyPosition + Vector3.up * totalOffset; //新的骨盆位置计算： 原位置+ up方向 * offset。  \n    newPelvisPosition.y = Mathf.Lerp(_lastPelvisPositionY, newPelvisPosition.y, pelvisUpAndDownSpeed); //插值动画  \n    m_animator.bodyPosition = newPelvisPosition; //赋值  \n    _lastPelvisPositionY = m_animator.bodyPosition.y; //记录信息  \n}\n</code></pre>\n\n至于为什么要写这个代码需要大伙想一想因为当左右脚有差距的时候如果身体不移动的话也不太可能将脚贴近地面的吧,所以要根据双脚的差距来矫正位置\n  ![](./Foot-IK/footik.jpg)\n结合一下这幅图应该就看明白了\n","source":"_posts/Foot-IK.md","raw":"---\ntitle: Foot IK\ndate: 2024-09-27 17:31:18\ntags: Unity 3d C#\n---\n\n关于 Unity3d 中的反向动力学代码解读\n\n<!-- more -->\n\n# 认识 IK (Inverse Kinematics)\n\n在 Unity3D 中的人物动画中有十个位置的 IK，分别是：\n\n- 头部\n- 左右手掌\n- 左右脚掌\n- 左右膝关节\n- 左右手肘关节\n  ![](./Foot-IK/NO.01.001.jpg)\n\n# IK 理解与权重\n\n看到上面的那几个红球吗？这些球就是在 Unity 分析骨骼时生成的。根据其他 UP 的解释，这些球表示肢体本应该到达的位置。\n\n我的理解是，以脚部为例，要实现反向动力学必须有一个运动的趋势。如果脚掌抬高，膝盖应该怎么移动呢？对，就是向给定的 IK 位置移动。作为一个初学者，我认为这样的理解方法最适合我，后期我会慢慢学习并修缮我的理解。\n\n## IK 权重\n\nIK 权重比较好理解。人物最初的动画都是按照设计来的，所以权重为零，这样就不会受到 IK 的影响。相反，权重越高，那个部位就会越靠近 IK 的位置，权重范围在(0,1)之间。\n\n<div style=\"display:flex;\">\n  <img src=\"./Foot-IK/anbi1.jpg\" width=\"200\" />\n  <img src=\"./Foot-IK/anbi2.jpg\" width=\"200\" />\n  <img src=\"./Foot-IK/anbi3.jpg\" width=\"200\" />\n</div>\n\n# 脚踝 IK 观察与代码解读\n\n在上面的三个图中，我将脚踝上的 IK 放到前面方便观察：\n\n- **第一张图**：权重等于零的时候，可以看到动画还是按照原先的动画效果来。\n- **第二张图**：随着权重的增加，脚踝的位置就慢慢向 IK 的位置靠近。\n\n## IK 相关函数\n\nIK 相关函数大体上分为三类：\n\n1. **设置 IK 位置和旋转**：\n\n   - `setIKposition(enum, vector3)` 来设置 IK 的位置\n   - `setIKrotation(enum, Quaternions)` 来设置旋转\n\n2. **设置权重**：\n   - `setIkweight(enum, float(0-1))` 来设置权重\n\n## 解读脚部 IK 代码\n\n<pre><code class=\"csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n \n[RequireComponent(typeof(Animator))]\npublic class IKSetting : MonoBehaviour\n{\n    public bool enableFeetIk = true; //是否开启ik\n    [Range(0, 2)] [SerializeField] private float heightFromGroundRaycast = 1.2f; //从地面向上的cast距离\n    [Range(0, 2)] [SerializeField] private float raycastDownDistance = 1.5f; //向下cast 距离\n    [SerializeField] private LayerMask environmentLayer; //检测layer\n    [SerializeField] private float pelvisOffset = 0f; //盆骨offset\n    [Range(0, 1)] [SerializeField] private float pelvisUpAndDownSpeed = 0.28f; //盆骨赋值速度\n    [Range(0, 1)] [SerializeField] private float feetToIkPositionSpeed = 0.5f; //足IK赋值速度\n    public string leftFootAnimCurveName = \"LeftFoot\"; //权重曲线名称\n    public string rightFootAnimCurveName = \"RightFoot\"; //权重曲线名称\n    [Range(0, 100)] public float leftFootAngleOffset; //旋转偏移\n    [Range(0, 100)] public float rightFootAngleOffset; //旋转偏移\n    public bool useIkFeature = false; //是否使用IK旋转\n \n    public bool showSolverDebug = true;// Debug绘制\n \n    private Animator m_animator; //动画机\n \n    private Vector3 _rightFootPosition, _leftFootPosition; //足部骨骼posiition\n    private Vector3 _rightFootIkPosition, _leftFootIkPosition; //足部IK position\n    private Quaternion _leftFootIkRotation, _rightFootIkRotation; //足部IK rotation\n    private float _lastPelvisPositionY, _lastRightFootPositionY, _lastLeftFootPositionY; //上帧信息，用于lerp动画\n \n    #region for Gizmos\n    private Vector3 rightHitPoint;\n    private Vector3 leftHitPoint;\n    private bool flip = false;\n    #endregion\n \n    private void Start()\n    {\n        m_animator = GetComponent<Animator>();\n    }\n \n    private void FixedUpdate()\n    {\n        if (!enableFeetIk) return;\n        if (!m_animator) return;\n \n        \n        AdjustFeetTarget(ref _rightFootPosition, HumanBodyBones.RightFoot); //设置 足部骨骼posiition\n        AdjustFeetTarget(ref _leftFootPosition, HumanBodyBones.LeftFoot); // 设置 足部骨骼posiition\n \n        FootPositionSolver(_rightFootPosition, ref _rightFootIkPosition, ref _rightFootIkRotation, rightFootAngleOffset); //IK 解算\n        FootPositionSolver(_leftFootPosition, ref _leftFootIkPosition, ref _leftFootIkRotation, leftFootAngleOffset);\n    }\n \n    private void OnAnimatorIK(int layerIndex)\n    {\n        if (!enableFeetIk) return;\n        if (!m_animator) return;\n \n        MovePelvisHeight(); //骨盆偏移\n \n        m_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //保证行走的时候脚部脱离,不然会粘在地上\n        if (useIkFeature)\n        {\n            m_animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //设置 rot 权重\n        }\n        MoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY); //设置ik goal坐标\n \n        m_animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));\n        if (useIkFeature)\n        {\n            m_animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));\n        }\n        MoveFeetToIkPoint(AvatarIKGoal.LeftFoot, _leftFootIkPosition, _leftFootIkRotation, ref _lastLeftFootPositionY);\n    }\n \n    void MoveFeetToIkPoint(AvatarIKGoal foot, Vector3 positionIkHolder, Quaternion rotationIkHolder, ref float lastFootPositionY)\n    {\n        Vector3 targetIkPosition = m_animator.GetIKPosition(foot); //获得红色圆球的位置\n \n        if (positionIkHolder != Vector3.zero) //如果新的IK pos 不为 0 \n        {\n            targetIkPosition = transform.InverseTransformPoint(targetIkPosition); //把原本的ik goal 的pos转换到本地坐标系\n            positionIkHolder = transform.InverseTransformPoint(positionIkHolder); //把现在的ik goal 的pos转到本地坐标系\n \n            float yVar = Mathf.Lerp(lastFootPositionY, positionIkHolder.y, feetToIkPositionSpeed); //进行插值\n            targetIkPosition.y += yVar;\n            lastFootPositionY = yVar;\n \n            targetIkPosition = transform.TransformPoint(targetIkPosition); //把新的ik goal pos转到世界坐标系\n \n            m_animator.SetIKRotation(foot, rotationIkHolder); //旋转赋予\n        }\n        m_animator.SetIKPosition(foot, targetIkPosition); //位置赋予\n    }\n \n    void MovePelvisHeight() //调整pelvis，保证IK 能达到（比如左右脚高度差那种）\n    {\n        if (_rightFootIkPosition == Vector3.zero || _leftFootIkPosition == Vector3.zero || _lastPelvisPositionY == 0f)\n        {\n            _lastPelvisPositionY = m_animator.bodyPosition.y;\n            return;\n        }\n \n        float lOffsetPosition = _leftFootIkPosition.y - transform.position.y; //左脚ik pos与当前transform的高度差\n        float rOffsetPosition = _rightFootIkPosition.y - transform.position.y; //右脚ik pos 与当前transform的高度差\n \n        //选择较小值（在以vector3.up为正轴的情况下）\n        //如果是正值，则向上偏移距离较小的。\n        //如果是负值，则向下偏移距离较大的。\n        float totalOffset = (lOffsetPosition < rOffsetPosition) ? lOffsetPosition : rOffsetPosition;\n \n        Vector3 newPelvisPosition = m_animator.bodyPosition + Vector3.up * totalOffset; //新的骨盆位置计算： 原位置+ up方向 * offset。\n        newPelvisPosition.y = Mathf.Lerp(_lastPelvisPositionY, newPelvisPosition.y, pelvisUpAndDownSpeed); //插值动画\n        m_animator.bodyPosition = newPelvisPosition; //赋值\n        _lastPelvisPositionY = m_animator.bodyPosition.y; //记录信息\n    }\n \n    void FootPositionSolver(Vector3 fromSkyPosition, ref Vector3 feetIkPosition, ref Quaternion feetIkRotation, float angleOffset)\n    {\n        if (showSolverDebug)\n        {\n            Debug.DrawLine(fromSkyPosition, fromSkyPosition + Vector3.down * (raycastDownDistance), Color.green);\n            Debug.Log(\"fromskyposition:\"+fromSkyPosition);\n        }\n \n        if (Physics.Raycast(fromSkyPosition, Vector3.down, out var feetOutHit, raycastDownDistance+ heightFromGroundRaycast, environmentLayer))\n        {\n            feetIkPosition = fromSkyPosition; //保存x,z值。\n            feetIkPosition.y = feetOutHit.point.y + pelvisOffset; //hit pos 的 Y 赋值\n \n            feetIkRotation = Quaternion.FromToRotation(Vector3.up, feetOutHit.normal) * transform.rotation; //计算法向偏移\n            feetIkRotation = Quaternion.AngleAxis(angleOffset, Vector3.up) * feetIkRotation; //计算额外的偏移\n \n            return;\n        }\n        feetIkPosition = Vector3.zero; //没有hit，归零\n    }\n \n    void AdjustFeetTarget(ref Vector3 feetPosition, HumanBodyBones foot)\n    {\n        \n        feetPosition = m_animator.GetBoneTransform(foot).position; //获取人形足部的transform position\n        feetPosition.y = transform.position.y + heightFromGroundRaycast; //y的值会加上【向上检测的距离】，主要是防止卡模型。\n       \n    }\n    private void OnDrawGizmos()\n    {\n        Gizmos.DrawSphere(rightHitPoint, 1.0f);\n        Gizmos.DrawSphere(leftHitPoint, 0.01f);\n    }\n}\n</code></pre>\n\n看到上面代码的你肯定是一脸懵逼 ,下面就让我来一一解读、\n\n<pre><code class=\"csharp\">[RequireComponent(typeof(Animator))]\n</code></pre>\n\n这个提一嘴免得有人还不知道,所挂载的物体上必须要有一个 Animator 组件\n\n<pre><code class=\"csharp\">\npublic bool enableFeetIk = true; //是否开启ik  \n[Range(0, 2)] [SerializeField] private float heightFromGroundRaycast = 1.2f; //从地面向上的cast距离  \n[Range(0, 2)] [SerializeField] private float raycastDownDistance = 1.5f; //向下cast 距离  \n[SerializeField] private LayerMask environmentLayer; //检测layer  \n[SerializeField] private float pelvisOffset = 0f; //盆骨offset  \n[Range(0, 1)] [SerializeField] private float pelvisUpAndDownSpeed = 0.28f; //盆骨赋值速度  \n[Range(0, 1)] [SerializeField] private float feetToIkPositionSpeed = 0.5f; //足IK赋值速度  \npublic string leftFootAnimCurveName = \"LeftFoot\"; //权重曲线名称  \npublic string rightFootAnimCurveName = \"RightFoot\"; //权重曲线名称  \n[Range(0, 100)] public float leftFootAngleOffset; //旋转偏移  \n[Range(0, 100)] public float rightFootAngleOffset; //旋转偏移  \npublic bool useIkFeature = false; //是否使用IK旋转  \n\npublic bool showSolverDebug = true;// Debug绘制  \n\nprivate Animator m_animator; //动画机  \n\nprivate Vector3 _rightFootPosition, _leftFootPosition; //足部骨骼posiition  \nprivate Vector3 _rightFootIkPosition, _leftFootIkPosition; //足部IK position  \nprivate Quaternion _leftFootIkRotation, _rightFootIkRotation; //足部IK rotation  \nprivate float _lastPelvisPositionY, _lastRightFootPositionY, _lastLeftFootPositionY; //上帧信息，用于lerp动画  \n\n#region for Gizmos  \nprivate Vector3 rightHitPoint;  \nprivate Vector3 leftHitPoint;  \nprivate bool flip = false;  \n#endregion  \n\nprivate void Start()  \n{  \n    m_animator = GetComponent<Animator>();  \n}\n</code></pre>\n\n这一块代码首先说明一下这个\n\n<pre><code class=\"csharp\">[Range(0, 2)] [SerializeField]  \n</code></pre>\n\n这个就是表明在 unity3d 编辑器界面的范围,而第二个就是表示可以序列化(说人话就是即使是 private 也可以被修改)\n\n其他的看看注释就行了\n\n<pre><code class=\"csharp\">#region for Gizmos  \nprivate Vector3 rightHitPoint;  \nprivate Vector3 leftHitPoint;  \nprivate bool flip = false;\n</code></pre>\n\n这段代码应该是在 unity3d 界面上画的,和具体功能无关,只是想画出接触点的位置不必理会\n\n来看看 void fixedupdate 里面的 AdjustFeetTarget 这个函数其函数定义如下\n\n<pre><code class=\"csharp\">void AdjustFeetTarget(ref Vector3 feetPosition, HumanBodyBones foot)  \n{  \n    feetPosition = m_animator.GetBoneTransform(foot).position; //获取人形足部的transform position  \n    feetPosition.y = transform.position.y + heightFromGroundRaycast; //y的值会加上【向上检测的距离】，主要是防止卡模型。  \n}\n</code></pre>\n\n这个函数的作用就是时时刻刻计算出检测点发射的位置,并且通过 ref feetposition 回调,方便下面的检测碰撞体使用,下面就来看看 FootPositionSolver 这个函数\n\n<pre><code class=\"csharp\">\nvoid FootPositionSolver(Vector3 fromSkyPosition, ref Vector3 feetIkPosition, ref Quaternion feetIkRotation, float angleOffset)  \n{  \n    if (showSolverDebug)  \n    {  \n        Debug.DrawLine(fromSkyPosition, fromSkyPosition + Vector3.down * (raycastDownDistance), Color.green);  \n        Debug.Log(\"fromskyposition:\"+fromSkyPosition);  \n    }  \n\n    if (Physics.Raycast(fromSkyPosition, Vector3.down, out var feetOutHit, raycastDownDistance+ heightFromGroundRaycast, environmentLayer))  \n    {  \n        feetIkPosition = fromSkyPosition; //保存x,z值。  \n        feetIkPosition.y = feetOutHit.point.y + pelvisOffset; //hit pos 的 Y 赋值  \n\n        feetIkRotation = Quaternion.FromToRotation(Vector3.up, feetOutHit.normal) * transform.rotation; //计算法向偏移  \n        feetIkRotation = Quaternion.AngleAxis(angleOffset, Vector3.up) * feetIkRotation; //计算额外的偏移  \n\n        return;  \n    }  \n    feetIkPosition = Vector3.zero; //没有hit，归零  \n}\n</code></pre>\n\n第一个 if 语句就是要不要绘制那条检测射线\n\n然后第二个判断语句就是检测碰撞体,也十分容易理解\n\nFromToRotation 函数计算从 Vector3.up 到 feetOutHit.normal 的旋转，这样就可以使角色的脚与地面的法线方向对齐,四元数我现在还没开始学所以只能记住用法了\n\nfeetIkRotation = Quaternion.AngleAxis(angleOffset, Vector3.up) \\* feetIkRotation; //计算额外的偏移这个也是一样就是脚掌的向内外偏移\n\n最后就得到了脚掌的 IK 了\n\n相反如果没有碰撞体的话就返回零,注意这里没有碰撞体是指悬浮在空中,不是站在地面上,因为站在地面上的碰撞体就是地面\n\n接下来就是 private void OnAnimatorIK(int layerIndex),这个函数只有在动画设置了 IK pass 的时候才能调用,并且也只能在这里设置 IK 相应的函数\n\n<pre><code class=\"csharp\">\nprivate void OnAnimatorIK(int layerIndex)  \n{  \n    if (!enableFeetIk) return;  \n    if (!m_animator) return;  \n\n    MovePelvisHeight(); //骨盆偏移  \n\n    m_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //保证行走的时候脚部脱离,不然会粘在地上  \n    if (useIkFeature)  \n    {  \n        m_animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //设置 rot 权重  \n    }  \n    MoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY); //设置ik goal坐标  \n\n    m_animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));  \n    if (useIkFeature)  \n    {  \n        m_animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));  \n    }  \n    MoveFeetToIkPoint(AvatarIKGoal.LeftFoot, _leftFootIkPosition, _leftFootIkRotation, ref _lastLeftFootPositionY);  \n}\n</code></pre>\n\n前面两个语句就是防止报错写的不必多想\n\n我们先说简单的\n\n<pre><code class=\"csharp\">\nm_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName));  \n</code></pre>\n\n这个就是根据动画曲线来设置权重,为什么要这样做捏,因为在人物跑步的时候总不能设置权重为 1 吧,这样就好像人的脚被锁住了,所以这里通过设置动画曲线的形式在和权重联动\n\n接下来稍微需要一点思考的\n\n<pre><code class=\"csharp\">\nMoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY);  \n</code></pre>\n\n<pre><code class=\"csharp\">\nvoid MoveFeetToIkPoint(AvatarIKGoal foot, Vector3 positionIkHolder, Quaternion rotationIkHolder, ref float lastFootPositionY)  \n{  \n    Vector3 targetIkPosition = m_animator.GetIKPosition(foot); //获得红色圆球的位置  \n\n    if (positionIkHolder != Vector3.zero) //如果新的IK pos 不为 0   \n    {  \n        targetIkPosition = transform.InverseTransformPoint(targetIkPosition); //把原本的ik goal 的pos转换到本地坐标系  \n        positionIkHolder = transform.InverseTransformPoint(positionIkHolder); //把现在的ik goal 的pos转到本地坐标系  \n\n        float yVar = Mathf.Lerp(lastFootPositionY, positionIkHolder.y, feetToIkPositionSpeed); //进行插值  \n        targetIkPosition.y += yVar;  \n        lastFootPositionY = yVar;  \n\n        targetIkPosition = transform.TransformPoint(targetIkPosition); //把新的ik goal pos转到世界坐标系  \n\n        m_animator.SetIKRotation(foot, rotationIkHolder); //旋转赋予  \n    }  \n    m_animator.SetIKPosition(foot, targetIkPosition); //位置赋予  \n}\n</code></pre>\n\n刚刚说过了如果 IK 等于零的话不就是飞在天上了嘛,所以这种情况就不用判断了  \n这个代码的解决方案就是先将脚踝的 IK(已经经过上面的计算得到了结果)转化成相对于父物体的本地坐标,下面的也是一样\n\n奇怪的东西就来了你一定会注意到 lastFootPositionY 这个东西在哪里用过,然后按住 Ctrl 点击这个发现只有这里用了,其实这个是因为脚部的初始位置本来就是零,所以这里就直接按照默认值来了,然后又出现了新的问题,就是这个\"+=\"为什么不是\"=\"呢，因为这个是本地坐标也就是脚掌到 IK 原本的距离,然后通过计算从脚踝到碰撞面的距离进行插值这样就可以实现脚部 IK 了\n\n最后再来介绍一下\n\n<pre><code class=\"csharp\">\nvoid MovePelvisHeight() //调整pelvis，保证IK 能达到（比如左右脚高度差那种）  \n{  \n    if (_rightFootIkPosition == Vector3.zero || _leftFootIkPosition == Vector3.zero || _lastPelvisPositionY == 0f)  \n    {  \n        _lastPelvisPositionY = m_animator.bodyPosition.y;  \n        return;  \n    }  \n\n    float lOffsetPosition = _leftFootIkPosition.y - transform.position.y; //左脚ik pos与当前transform的高度差  \n    float rOffsetPosition = _rightFootIkPosition.y - transform.position.y; //右脚ik pos 与当前transform的高度差  \n\n    //选择较小值（在以vector3.up为正轴的情况下）  \n    //如果是正值，则向上偏移距离较小的。  \n    //如果是负值，则向下偏移距离较大的。  \n    float totalOffset = (lOffsetPosition < rOffsetPosition) ? lOffsetPosition : rOffsetPosition;  \n\n    Vector3 newPelvisPosition = m_animator.bodyPosition + Vector3.up * totalOffset; //新的骨盆位置计算： 原位置+ up方向 * offset。  \n    newPelvisPosition.y = Mathf.Lerp(_lastPelvisPositionY, newPelvisPosition.y, pelvisUpAndDownSpeed); //插值动画  \n    m_animator.bodyPosition = newPelvisPosition; //赋值  \n    _lastPelvisPositionY = m_animator.bodyPosition.y; //记录信息  \n}\n</code></pre>\n\n至于为什么要写这个代码需要大伙想一想因为当左右脚有差距的时候如果身体不移动的话也不太可能将脚贴近地面的吧,所以要根据双脚的差距来矫正位置\n  ![](./Foot-IK/footik.jpg)\n结合一下这幅图应该就看明白了\n","slug":"Foot-IK","published":1,"updated":"2024-09-27T11:59:56.298Z","comments":1,"layout":"post","photos":[],"_id":"cm1muoetw0003sc7q7qvehoko","content":"<p>关于 Unity3d 中的反向动力学代码解读</p>\n<span id=\"more\"></span>\n\n<h1 id=\"认识-IK-Inverse-Kinematics\"><a href=\"#认识-IK-Inverse-Kinematics\" class=\"headerlink\" title=\"认识 IK (Inverse Kinematics)\"></a>认识 IK (Inverse Kinematics)</h1><p>在 Unity3D 中的人物动画中有十个位置的 IK，分别是：</p>\n<ul>\n<li>头部</li>\n<li>左右手掌</li>\n<li>左右脚掌</li>\n<li>左右膝关节</li>\n<li>左右手肘关节<br><img src=\"/2024/09/27/Foot-IK/NO.01.001.jpg\"></li>\n</ul>\n<h1 id=\"IK-理解与权重\"><a href=\"#IK-理解与权重\" class=\"headerlink\" title=\"IK 理解与权重\"></a>IK 理解与权重</h1><p>看到上面的那几个红球吗？这些球就是在 Unity 分析骨骼时生成的。根据其他 UP 的解释，这些球表示肢体本应该到达的位置。</p>\n<p>我的理解是，以脚部为例，要实现反向动力学必须有一个运动的趋势。如果脚掌抬高，膝盖应该怎么移动呢？对，就是向给定的 IK 位置移动。作为一个初学者，我认为这样的理解方法最适合我，后期我会慢慢学习并修缮我的理解。</p>\n<h2 id=\"IK-权重\"><a href=\"#IK-权重\" class=\"headerlink\" title=\"IK 权重\"></a>IK 权重</h2><p>IK 权重比较好理解。人物最初的动画都是按照设计来的，所以权重为零，这样就不会受到 IK 的影响。相反，权重越高，那个部位就会越靠近 IK 的位置，权重范围在(0,1)之间。</p>\n<div style=\"display:flex;\">\n  <img src=\"/2024/09/27/Foot-IK/anbi1.jpg\" width=\"200\">\n  <img src=\"/2024/09/27/Foot-IK/anbi2.jpg\" width=\"200\">\n  <img src=\"/2024/09/27/Foot-IK/anbi3.jpg\" width=\"200\">\n</div>\n\n<h1 id=\"脚踝-IK-观察与代码解读\"><a href=\"#脚踝-IK-观察与代码解读\" class=\"headerlink\" title=\"脚踝 IK 观察与代码解读\"></a>脚踝 IK 观察与代码解读</h1><p>在上面的三个图中，我将脚踝上的 IK 放到前面方便观察：</p>\n<ul>\n<li><strong>第一张图</strong>：权重等于零的时候，可以看到动画还是按照原先的动画效果来。</li>\n<li><strong>第二张图</strong>：随着权重的增加，脚踝的位置就慢慢向 IK 的位置靠近。</li>\n</ul>\n<h2 id=\"IK-相关函数\"><a href=\"#IK-相关函数\" class=\"headerlink\" title=\"IK 相关函数\"></a>IK 相关函数</h2><p>IK 相关函数大体上分为三类：</p>\n<ol>\n<li><p><strong>设置 IK 位置和旋转</strong>：</p>\n<ul>\n<li><code>setIKposition(enum, vector3)</code> 来设置 IK 的位置</li>\n<li><code>setIKrotation(enum, Quaternions)</code> 来设置旋转</li>\n</ul>\n</li>\n<li><p><strong>设置权重</strong>：</p>\n<ul>\n<li><code>setIkweight(enum, float(0-1))</code> 来设置权重</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"解读脚部-IK-代码\"><a href=\"#解读脚部-IK-代码\" class=\"headerlink\" title=\"解读脚部 IK 代码\"></a>解读脚部 IK 代码</h2><pre><code class=\"csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n \n[RequireComponent(typeof(Animator))]\npublic class IKSetting : MonoBehaviour\n&#123;\n    public bool enableFeetIk = true; //是否开启ik\n    [Range(0, 2)] [SerializeField] private float heightFromGroundRaycast = 1.2f; //从地面向上的cast距离\n    [Range(0, 2)] [SerializeField] private float raycastDownDistance = 1.5f; //向下cast 距离\n    [SerializeField] private LayerMask environmentLayer; //检测layer\n    [SerializeField] private float pelvisOffset = 0f; //盆骨offset\n    [Range(0, 1)] [SerializeField] private float pelvisUpAndDownSpeed = 0.28f; //盆骨赋值速度\n    [Range(0, 1)] [SerializeField] private float feetToIkPositionSpeed = 0.5f; //足IK赋值速度\n    public string leftFootAnimCurveName = \"LeftFoot\"; //权重曲线名称\n    public string rightFootAnimCurveName = \"RightFoot\"; //权重曲线名称\n    [Range(0, 100)] public float leftFootAngleOffset; //旋转偏移\n    [Range(0, 100)] public float rightFootAngleOffset; //旋转偏移\n    public bool useIkFeature = false; //是否使用IK旋转\n \n    public bool showSolverDebug = true;// Debug绘制\n \n    private Animator m_animator; //动画机\n \n    private Vector3 _rightFootPosition, _leftFootPosition; //足部骨骼posiition\n    private Vector3 _rightFootIkPosition, _leftFootIkPosition; //足部IK position\n    private Quaternion _leftFootIkRotation, _rightFootIkRotation; //足部IK rotation\n    private float _lastPelvisPositionY, _lastRightFootPositionY, _lastLeftFootPositionY; //上帧信息，用于lerp动画\n \n    #region for Gizmos\n    private Vector3 rightHitPoint;\n    private Vector3 leftHitPoint;\n    private bool flip = false;\n    #endregion\n \n    private void Start()\n    &#123;\n        m_animator = GetComponent<Animator>();\n    &#125;\n \n    private void FixedUpdate()\n    &#123;\n        if (!enableFeetIk) return;\n        if (!m_animator) return;\n \n        \n        AdjustFeetTarget(ref _rightFootPosition, HumanBodyBones.RightFoot); //设置 足部骨骼posiition\n        AdjustFeetTarget(ref _leftFootPosition, HumanBodyBones.LeftFoot); // 设置 足部骨骼posiition\n \n        FootPositionSolver(_rightFootPosition, ref _rightFootIkPosition, ref _rightFootIkRotation, rightFootAngleOffset); //IK 解算\n        FootPositionSolver(_leftFootPosition, ref _leftFootIkPosition, ref _leftFootIkRotation, leftFootAngleOffset);\n    &#125;\n \n    private void OnAnimatorIK(int layerIndex)\n    &#123;\n        if (!enableFeetIk) return;\n        if (!m_animator) return;\n \n        MovePelvisHeight(); //骨盆偏移\n \n        m_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //保证行走的时候脚部脱离,不然会粘在地上\n        if (useIkFeature)\n        &#123;\n            m_animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //设置 rot 权重\n        &#125;\n        MoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY); //设置ik goal坐标\n \n        m_animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));\n        if (useIkFeature)\n        &#123;\n            m_animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));\n        &#125;\n        MoveFeetToIkPoint(AvatarIKGoal.LeftFoot, _leftFootIkPosition, _leftFootIkRotation, ref _lastLeftFootPositionY);\n    &#125;\n \n    void MoveFeetToIkPoint(AvatarIKGoal foot, Vector3 positionIkHolder, Quaternion rotationIkHolder, ref float lastFootPositionY)\n    &#123;\n        Vector3 targetIkPosition = m_animator.GetIKPosition(foot); //获得红色圆球的位置\n \n        if (positionIkHolder != Vector3.zero) //如果新的IK pos 不为 0 \n        &#123;\n            targetIkPosition = transform.InverseTransformPoint(targetIkPosition); //把原本的ik goal 的pos转换到本地坐标系\n            positionIkHolder = transform.InverseTransformPoint(positionIkHolder); //把现在的ik goal 的pos转到本地坐标系\n \n            float yVar = Mathf.Lerp(lastFootPositionY, positionIkHolder.y, feetToIkPositionSpeed); //进行插值\n            targetIkPosition.y += yVar;\n            lastFootPositionY = yVar;\n \n            targetIkPosition = transform.TransformPoint(targetIkPosition); //把新的ik goal pos转到世界坐标系\n \n            m_animator.SetIKRotation(foot, rotationIkHolder); //旋转赋予\n        &#125;\n        m_animator.SetIKPosition(foot, targetIkPosition); //位置赋予\n    &#125;\n \n    void MovePelvisHeight() //调整pelvis，保证IK 能达到（比如左右脚高度差那种）\n    &#123;\n        if (_rightFootIkPosition == Vector3.zero || _leftFootIkPosition == Vector3.zero || _lastPelvisPositionY == 0f)\n        &#123;\n            _lastPelvisPositionY = m_animator.bodyPosition.y;\n            return;\n        &#125;\n \n        float lOffsetPosition = _leftFootIkPosition.y - transform.position.y; //左脚ik pos与当前transform的高度差\n        float rOffsetPosition = _rightFootIkPosition.y - transform.position.y; //右脚ik pos 与当前transform的高度差\n \n        //选择较小值（在以vector3.up为正轴的情况下）\n        //如果是正值，则向上偏移距离较小的。\n        //如果是负值，则向下偏移距离较大的。\n        float totalOffset = (lOffsetPosition < rOffsetPosition) ? lOffsetPosition : rOffsetPosition;\n \n        Vector3 newPelvisPosition = m_animator.bodyPosition + Vector3.up * totalOffset; //新的骨盆位置计算： 原位置+ up方向 * offset。\n        newPelvisPosition.y = Mathf.Lerp(_lastPelvisPositionY, newPelvisPosition.y, pelvisUpAndDownSpeed); //插值动画\n        m_animator.bodyPosition = newPelvisPosition; //赋值\n        _lastPelvisPositionY = m_animator.bodyPosition.y; //记录信息\n    &#125;\n \n    void FootPositionSolver(Vector3 fromSkyPosition, ref Vector3 feetIkPosition, ref Quaternion feetIkRotation, float angleOffset)\n    &#123;\n        if (showSolverDebug)\n        &#123;\n            Debug.DrawLine(fromSkyPosition, fromSkyPosition + Vector3.down * (raycastDownDistance), Color.green);\n            Debug.Log(\"fromskyposition:\"+fromSkyPosition);\n        &#125;\n \n        if (Physics.Raycast(fromSkyPosition, Vector3.down, out var feetOutHit, raycastDownDistance+ heightFromGroundRaycast, environmentLayer))\n        &#123;\n            feetIkPosition = fromSkyPosition; //保存x,z值。\n            feetIkPosition.y = feetOutHit.point.y + pelvisOffset; //hit pos 的 Y 赋值\n \n            feetIkRotation = Quaternion.FromToRotation(Vector3.up, feetOutHit.normal) * transform.rotation; //计算法向偏移\n            feetIkRotation = Quaternion.AngleAxis(angleOffset, Vector3.up) * feetIkRotation; //计算额外的偏移\n \n            return;\n        &#125;\n        feetIkPosition = Vector3.zero; //没有hit，归零\n    &#125;\n \n    void AdjustFeetTarget(ref Vector3 feetPosition, HumanBodyBones foot)\n    &#123;\n        \n        feetPosition = m_animator.GetBoneTransform(foot).position; //获取人形足部的transform position\n        feetPosition.y = transform.position.y + heightFromGroundRaycast; //y的值会加上【向上检测的距离】，主要是防止卡模型。\n       \n    &#125;\n    private void OnDrawGizmos()\n    &#123;\n        Gizmos.DrawSphere(rightHitPoint, 1.0f);\n        Gizmos.DrawSphere(leftHitPoint, 0.01f);\n    &#125;\n&#125;\n</Animator></code></pre>\n\n<p>看到上面代码的你肯定是一脸懵逼 ,下面就让我来一一解读、</p>\n<pre><code class=\"csharp\">[RequireComponent(typeof(Animator))]\n</code></pre>\n\n<p>这个提一嘴免得有人还不知道,所挂载的物体上必须要有一个 Animator 组件</p>\n<pre><code class=\"csharp\">\npublic bool enableFeetIk = true; //是否开启ik  \n[Range(0, 2)] [SerializeField] private float heightFromGroundRaycast = 1.2f; //从地面向上的cast距离  \n[Range(0, 2)] [SerializeField] private float raycastDownDistance = 1.5f; //向下cast 距离  \n[SerializeField] private LayerMask environmentLayer; //检测layer  \n[SerializeField] private float pelvisOffset = 0f; //盆骨offset  \n[Range(0, 1)] [SerializeField] private float pelvisUpAndDownSpeed = 0.28f; //盆骨赋值速度  \n[Range(0, 1)] [SerializeField] private float feetToIkPositionSpeed = 0.5f; //足IK赋值速度  \npublic string leftFootAnimCurveName = \"LeftFoot\"; //权重曲线名称  \npublic string rightFootAnimCurveName = \"RightFoot\"; //权重曲线名称  \n[Range(0, 100)] public float leftFootAngleOffset; //旋转偏移  \n[Range(0, 100)] public float rightFootAngleOffset; //旋转偏移  \npublic bool useIkFeature = false; //是否使用IK旋转  \n\npublic bool showSolverDebug = true;// Debug绘制  \n\nprivate Animator m_animator; //动画机  \n\nprivate Vector3 _rightFootPosition, _leftFootPosition; //足部骨骼posiition  \nprivate Vector3 _rightFootIkPosition, _leftFootIkPosition; //足部IK position  \nprivate Quaternion _leftFootIkRotation, _rightFootIkRotation; //足部IK rotation  \nprivate float _lastPelvisPositionY, _lastRightFootPositionY, _lastLeftFootPositionY; //上帧信息，用于lerp动画  \n\n#region for Gizmos  \nprivate Vector3 rightHitPoint;  \nprivate Vector3 leftHitPoint;  \nprivate bool flip = false;  \n#endregion  \n\nprivate void Start()  \n&#123;  \n    m_animator = GetComponent<Animator>();  \n&#125;\n</Animator></code></pre>\n\n<p>这一块代码首先说明一下这个</p>\n<pre><code class=\"csharp\">[Range(0, 2)] [SerializeField]  \n</code></pre>\n\n<p>这个就是表明在 unity3d 编辑器界面的范围,而第二个就是表示可以序列化(说人话就是即使是 private 也可以被修改)</p>\n<p>其他的看看注释就行了</p>\n<pre><code class=\"csharp\">#region for Gizmos  \nprivate Vector3 rightHitPoint;  \nprivate Vector3 leftHitPoint;  \nprivate bool flip = false;\n</code></pre>\n\n<p>这段代码应该是在 unity3d 界面上画的,和具体功能无关,只是想画出接触点的位置不必理会</p>\n<p>来看看 void fixedupdate 里面的 AdjustFeetTarget 这个函数其函数定义如下</p>\n<pre><code class=\"csharp\">void AdjustFeetTarget(ref Vector3 feetPosition, HumanBodyBones foot)  \n&#123;  \n    feetPosition = m_animator.GetBoneTransform(foot).position; //获取人形足部的transform position  \n    feetPosition.y = transform.position.y + heightFromGroundRaycast; //y的值会加上【向上检测的距离】，主要是防止卡模型。  \n&#125;\n</code></pre>\n\n<p>这个函数的作用就是时时刻刻计算出检测点发射的位置,并且通过 ref feetposition 回调,方便下面的检测碰撞体使用,下面就来看看 FootPositionSolver 这个函数</p>\n<pre><code class=\"csharp\">\nvoid FootPositionSolver(Vector3 fromSkyPosition, ref Vector3 feetIkPosition, ref Quaternion feetIkRotation, float angleOffset)  \n&#123;  \n    if (showSolverDebug)  \n    &#123;  \n        Debug.DrawLine(fromSkyPosition, fromSkyPosition + Vector3.down * (raycastDownDistance), Color.green);  \n        Debug.Log(\"fromskyposition:\"+fromSkyPosition);  \n    &#125;  \n\n    if (Physics.Raycast(fromSkyPosition, Vector3.down, out var feetOutHit, raycastDownDistance+ heightFromGroundRaycast, environmentLayer))  \n    &#123;  \n        feetIkPosition = fromSkyPosition; //保存x,z值。  \n        feetIkPosition.y = feetOutHit.point.y + pelvisOffset; //hit pos 的 Y 赋值  \n\n        feetIkRotation = Quaternion.FromToRotation(Vector3.up, feetOutHit.normal) * transform.rotation; //计算法向偏移  \n        feetIkRotation = Quaternion.AngleAxis(angleOffset, Vector3.up) * feetIkRotation; //计算额外的偏移  \n\n        return;  \n    &#125;  \n    feetIkPosition = Vector3.zero; //没有hit，归零  \n&#125;\n</code></pre>\n\n<p>第一个 if 语句就是要不要绘制那条检测射线</p>\n<p>然后第二个判断语句就是检测碰撞体,也十分容易理解</p>\n<p>FromToRotation 函数计算从 Vector3.up 到 feetOutHit.normal 的旋转，这样就可以使角色的脚与地面的法线方向对齐,四元数我现在还没开始学所以只能记住用法了</p>\n<p>feetIkRotation &#x3D; Quaternion.AngleAxis(angleOffset, Vector3.up) * feetIkRotation; &#x2F;&#x2F;计算额外的偏移这个也是一样就是脚掌的向内外偏移</p>\n<p>最后就得到了脚掌的 IK 了</p>\n<p>相反如果没有碰撞体的话就返回零,注意这里没有碰撞体是指悬浮在空中,不是站在地面上,因为站在地面上的碰撞体就是地面</p>\n<p>接下来就是 private void OnAnimatorIK(int layerIndex),这个函数只有在动画设置了 IK pass 的时候才能调用,并且也只能在这里设置 IK 相应的函数</p>\n<pre><code class=\"csharp\">\nprivate void OnAnimatorIK(int layerIndex)  \n&#123;  \n    if (!enableFeetIk) return;  \n    if (!m_animator) return;  \n\n    MovePelvisHeight(); //骨盆偏移  \n\n    m_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //保证行走的时候脚部脱离,不然会粘在地上  \n    if (useIkFeature)  \n    &#123;  \n        m_animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //设置 rot 权重  \n    &#125;  \n    MoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY); //设置ik goal坐标  \n\n    m_animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));  \n    if (useIkFeature)  \n    &#123;  \n        m_animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));  \n    &#125;  \n    MoveFeetToIkPoint(AvatarIKGoal.LeftFoot, _leftFootIkPosition, _leftFootIkRotation, ref _lastLeftFootPositionY);  \n&#125;\n</code></pre>\n\n<p>前面两个语句就是防止报错写的不必多想</p>\n<p>我们先说简单的</p>\n<pre><code class=\"csharp\">\nm_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName));  \n</code></pre>\n\n<p>这个就是根据动画曲线来设置权重,为什么要这样做捏,因为在人物跑步的时候总不能设置权重为 1 吧,这样就好像人的脚被锁住了,所以这里通过设置动画曲线的形式在和权重联动</p>\n<p>接下来稍微需要一点思考的</p>\n<pre><code class=\"csharp\">\nMoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY);  \n</code></pre>\n\n<pre><code class=\"csharp\">\nvoid MoveFeetToIkPoint(AvatarIKGoal foot, Vector3 positionIkHolder, Quaternion rotationIkHolder, ref float lastFootPositionY)  \n&#123;  \n    Vector3 targetIkPosition = m_animator.GetIKPosition(foot); //获得红色圆球的位置  \n\n    if (positionIkHolder != Vector3.zero) //如果新的IK pos 不为 0   \n    &#123;  \n        targetIkPosition = transform.InverseTransformPoint(targetIkPosition); //把原本的ik goal 的pos转换到本地坐标系  \n        positionIkHolder = transform.InverseTransformPoint(positionIkHolder); //把现在的ik goal 的pos转到本地坐标系  \n\n        float yVar = Mathf.Lerp(lastFootPositionY, positionIkHolder.y, feetToIkPositionSpeed); //进行插值  \n        targetIkPosition.y += yVar;  \n        lastFootPositionY = yVar;  \n\n        targetIkPosition = transform.TransformPoint(targetIkPosition); //把新的ik goal pos转到世界坐标系  \n\n        m_animator.SetIKRotation(foot, rotationIkHolder); //旋转赋予  \n    &#125;  \n    m_animator.SetIKPosition(foot, targetIkPosition); //位置赋予  \n&#125;\n</code></pre>\n\n<p>刚刚说过了如果 IK 等于零的话不就是飞在天上了嘛,所以这种情况就不用判断了<br>这个代码的解决方案就是先将脚踝的 IK(已经经过上面的计算得到了结果)转化成相对于父物体的本地坐标,下面的也是一样</p>\n<p>奇怪的东西就来了你一定会注意到 lastFootPositionY 这个东西在哪里用过,然后按住 Ctrl 点击这个发现只有这里用了,其实这个是因为脚部的初始位置本来就是零,所以这里就直接按照默认值来了,然后又出现了新的问题,就是这个”+&#x3D;”为什么不是”&#x3D;”呢，因为这个是本地坐标也就是脚掌到 IK 原本的距离,然后通过计算从脚踝到碰撞面的距离进行插值这样就可以实现脚部 IK 了</p>\n<p>最后再来介绍一下</p>\n<pre><code class=\"csharp\">\nvoid MovePelvisHeight() //调整pelvis，保证IK 能达到（比如左右脚高度差那种）  \n&#123;  \n    if (_rightFootIkPosition == Vector3.zero || _leftFootIkPosition == Vector3.zero || _lastPelvisPositionY == 0f)  \n    &#123;  \n        _lastPelvisPositionY = m_animator.bodyPosition.y;  \n        return;  \n    &#125;  \n\n    float lOffsetPosition = _leftFootIkPosition.y - transform.position.y; //左脚ik pos与当前transform的高度差  \n    float rOffsetPosition = _rightFootIkPosition.y - transform.position.y; //右脚ik pos 与当前transform的高度差  \n\n    //选择较小值（在以vector3.up为正轴的情况下）  \n    //如果是正值，则向上偏移距离较小的。  \n    //如果是负值，则向下偏移距离较大的。  \n    float totalOffset = (lOffsetPosition < rOffsetPosition) ? lOffsetPosition : rOffsetPosition;  \n\n    Vector3 newPelvisPosition = m_animator.bodyPosition + Vector3.up * totalOffset; //新的骨盆位置计算： 原位置+ up方向 * offset。  \n    newPelvisPosition.y = Mathf.Lerp(_lastPelvisPositionY, newPelvisPosition.y, pelvisUpAndDownSpeed); //插值动画  \n    m_animator.bodyPosition = newPelvisPosition; //赋值  \n    _lastPelvisPositionY = m_animator.bodyPosition.y; //记录信息  \n&#125;\n</code></pre>\n\n<p>至于为什么要写这个代码需要大伙想一想因为当左右脚有差距的时候如果身体不移动的话也不太可能将脚贴近地面的吧,所以要根据双脚的差距来矫正位置<br>  <img src=\"/2024/09/27/Foot-IK/footik.jpg\"><br>结合一下这幅图应该就看明白了</p>\n","excerpt":"<p>关于 Unity3d 中的反向动力学代码解读</p>","more":"<h1 id=\"认识-IK-Inverse-Kinematics\"><a href=\"#认识-IK-Inverse-Kinematics\" class=\"headerlink\" title=\"认识 IK (Inverse Kinematics)\"></a>认识 IK (Inverse Kinematics)</h1><p>在 Unity3D 中的人物动画中有十个位置的 IK，分别是：</p>\n<ul>\n<li>头部</li>\n<li>左右手掌</li>\n<li>左右脚掌</li>\n<li>左右膝关节</li>\n<li>左右手肘关节<br><img src=\"/2024/09/27/Foot-IK/NO.01.001.jpg\"></li>\n</ul>\n<h1 id=\"IK-理解与权重\"><a href=\"#IK-理解与权重\" class=\"headerlink\" title=\"IK 理解与权重\"></a>IK 理解与权重</h1><p>看到上面的那几个红球吗？这些球就是在 Unity 分析骨骼时生成的。根据其他 UP 的解释，这些球表示肢体本应该到达的位置。</p>\n<p>我的理解是，以脚部为例，要实现反向动力学必须有一个运动的趋势。如果脚掌抬高，膝盖应该怎么移动呢？对，就是向给定的 IK 位置移动。作为一个初学者，我认为这样的理解方法最适合我，后期我会慢慢学习并修缮我的理解。</p>\n<h2 id=\"IK-权重\"><a href=\"#IK-权重\" class=\"headerlink\" title=\"IK 权重\"></a>IK 权重</h2><p>IK 权重比较好理解。人物最初的动画都是按照设计来的，所以权重为零，这样就不会受到 IK 的影响。相反，权重越高，那个部位就会越靠近 IK 的位置，权重范围在(0,1)之间。</p>\n<div style=\"display:flex;\">\n  <img src=\"/2024/09/27/Foot-IK/anbi1.jpg\" width=\"200\">\n  <img src=\"/2024/09/27/Foot-IK/anbi2.jpg\" width=\"200\">\n  <img src=\"/2024/09/27/Foot-IK/anbi3.jpg\" width=\"200\">\n</div>\n\n<h1 id=\"脚踝-IK-观察与代码解读\"><a href=\"#脚踝-IK-观察与代码解读\" class=\"headerlink\" title=\"脚踝 IK 观察与代码解读\"></a>脚踝 IK 观察与代码解读</h1><p>在上面的三个图中，我将脚踝上的 IK 放到前面方便观察：</p>\n<ul>\n<li><strong>第一张图</strong>：权重等于零的时候，可以看到动画还是按照原先的动画效果来。</li>\n<li><strong>第二张图</strong>：随着权重的增加，脚踝的位置就慢慢向 IK 的位置靠近。</li>\n</ul>\n<h2 id=\"IK-相关函数\"><a href=\"#IK-相关函数\" class=\"headerlink\" title=\"IK 相关函数\"></a>IK 相关函数</h2><p>IK 相关函数大体上分为三类：</p>\n<ol>\n<li><p><strong>设置 IK 位置和旋转</strong>：</p>\n<ul>\n<li><code>setIKposition(enum, vector3)</code> 来设置 IK 的位置</li>\n<li><code>setIKrotation(enum, Quaternions)</code> 来设置旋转</li>\n</ul>\n</li>\n<li><p><strong>设置权重</strong>：</p>\n<ul>\n<li><code>setIkweight(enum, float(0-1))</code> 来设置权重</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"解读脚部-IK-代码\"><a href=\"#解读脚部-IK-代码\" class=\"headerlink\" title=\"解读脚部 IK 代码\"></a>解读脚部 IK 代码</h2><pre><code class=\"csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n \n[RequireComponent(typeof(Animator))]\npublic class IKSetting : MonoBehaviour\n&#123;\n    public bool enableFeetIk = true; //是否开启ik\n    [Range(0, 2)] [SerializeField] private float heightFromGroundRaycast = 1.2f; //从地面向上的cast距离\n    [Range(0, 2)] [SerializeField] private float raycastDownDistance = 1.5f; //向下cast 距离\n    [SerializeField] private LayerMask environmentLayer; //检测layer\n    [SerializeField] private float pelvisOffset = 0f; //盆骨offset\n    [Range(0, 1)] [SerializeField] private float pelvisUpAndDownSpeed = 0.28f; //盆骨赋值速度\n    [Range(0, 1)] [SerializeField] private float feetToIkPositionSpeed = 0.5f; //足IK赋值速度\n    public string leftFootAnimCurveName = \"LeftFoot\"; //权重曲线名称\n    public string rightFootAnimCurveName = \"RightFoot\"; //权重曲线名称\n    [Range(0, 100)] public float leftFootAngleOffset; //旋转偏移\n    [Range(0, 100)] public float rightFootAngleOffset; //旋转偏移\n    public bool useIkFeature = false; //是否使用IK旋转\n \n    public bool showSolverDebug = true;// Debug绘制\n \n    private Animator m_animator; //动画机\n \n    private Vector3 _rightFootPosition, _leftFootPosition; //足部骨骼posiition\n    private Vector3 _rightFootIkPosition, _leftFootIkPosition; //足部IK position\n    private Quaternion _leftFootIkRotation, _rightFootIkRotation; //足部IK rotation\n    private float _lastPelvisPositionY, _lastRightFootPositionY, _lastLeftFootPositionY; //上帧信息，用于lerp动画\n \n    #region for Gizmos\n    private Vector3 rightHitPoint;\n    private Vector3 leftHitPoint;\n    private bool flip = false;\n    #endregion\n \n    private void Start()\n    &#123;\n        m_animator = GetComponent<Animator>();\n    &#125;\n \n    private void FixedUpdate()\n    &#123;\n        if (!enableFeetIk) return;\n        if (!m_animator) return;\n \n        \n        AdjustFeetTarget(ref _rightFootPosition, HumanBodyBones.RightFoot); //设置 足部骨骼posiition\n        AdjustFeetTarget(ref _leftFootPosition, HumanBodyBones.LeftFoot); // 设置 足部骨骼posiition\n \n        FootPositionSolver(_rightFootPosition, ref _rightFootIkPosition, ref _rightFootIkRotation, rightFootAngleOffset); //IK 解算\n        FootPositionSolver(_leftFootPosition, ref _leftFootIkPosition, ref _leftFootIkRotation, leftFootAngleOffset);\n    &#125;\n \n    private void OnAnimatorIK(int layerIndex)\n    &#123;\n        if (!enableFeetIk) return;\n        if (!m_animator) return;\n \n        MovePelvisHeight(); //骨盆偏移\n \n        m_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //保证行走的时候脚部脱离,不然会粘在地上\n        if (useIkFeature)\n        &#123;\n            m_animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //设置 rot 权重\n        &#125;\n        MoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY); //设置ik goal坐标\n \n        m_animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));\n        if (useIkFeature)\n        &#123;\n            m_animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));\n        &#125;\n        MoveFeetToIkPoint(AvatarIKGoal.LeftFoot, _leftFootIkPosition, _leftFootIkRotation, ref _lastLeftFootPositionY);\n    &#125;\n \n    void MoveFeetToIkPoint(AvatarIKGoal foot, Vector3 positionIkHolder, Quaternion rotationIkHolder, ref float lastFootPositionY)\n    &#123;\n        Vector3 targetIkPosition = m_animator.GetIKPosition(foot); //获得红色圆球的位置\n \n        if (positionIkHolder != Vector3.zero) //如果新的IK pos 不为 0 \n        &#123;\n            targetIkPosition = transform.InverseTransformPoint(targetIkPosition); //把原本的ik goal 的pos转换到本地坐标系\n            positionIkHolder = transform.InverseTransformPoint(positionIkHolder); //把现在的ik goal 的pos转到本地坐标系\n \n            float yVar = Mathf.Lerp(lastFootPositionY, positionIkHolder.y, feetToIkPositionSpeed); //进行插值\n            targetIkPosition.y += yVar;\n            lastFootPositionY = yVar;\n \n            targetIkPosition = transform.TransformPoint(targetIkPosition); //把新的ik goal pos转到世界坐标系\n \n            m_animator.SetIKRotation(foot, rotationIkHolder); //旋转赋予\n        &#125;\n        m_animator.SetIKPosition(foot, targetIkPosition); //位置赋予\n    &#125;\n \n    void MovePelvisHeight() //调整pelvis，保证IK 能达到（比如左右脚高度差那种）\n    &#123;\n        if (_rightFootIkPosition == Vector3.zero || _leftFootIkPosition == Vector3.zero || _lastPelvisPositionY == 0f)\n        &#123;\n            _lastPelvisPositionY = m_animator.bodyPosition.y;\n            return;\n        &#125;\n \n        float lOffsetPosition = _leftFootIkPosition.y - transform.position.y; //左脚ik pos与当前transform的高度差\n        float rOffsetPosition = _rightFootIkPosition.y - transform.position.y; //右脚ik pos 与当前transform的高度差\n \n        //选择较小值（在以vector3.up为正轴的情况下）\n        //如果是正值，则向上偏移距离较小的。\n        //如果是负值，则向下偏移距离较大的。\n        float totalOffset = (lOffsetPosition < rOffsetPosition) ? lOffsetPosition : rOffsetPosition;\n \n        Vector3 newPelvisPosition = m_animator.bodyPosition + Vector3.up * totalOffset; //新的骨盆位置计算： 原位置+ up方向 * offset。\n        newPelvisPosition.y = Mathf.Lerp(_lastPelvisPositionY, newPelvisPosition.y, pelvisUpAndDownSpeed); //插值动画\n        m_animator.bodyPosition = newPelvisPosition; //赋值\n        _lastPelvisPositionY = m_animator.bodyPosition.y; //记录信息\n    &#125;\n \n    void FootPositionSolver(Vector3 fromSkyPosition, ref Vector3 feetIkPosition, ref Quaternion feetIkRotation, float angleOffset)\n    &#123;\n        if (showSolverDebug)\n        &#123;\n            Debug.DrawLine(fromSkyPosition, fromSkyPosition + Vector3.down * (raycastDownDistance), Color.green);\n            Debug.Log(\"fromskyposition:\"+fromSkyPosition);\n        &#125;\n \n        if (Physics.Raycast(fromSkyPosition, Vector3.down, out var feetOutHit, raycastDownDistance+ heightFromGroundRaycast, environmentLayer))\n        &#123;\n            feetIkPosition = fromSkyPosition; //保存x,z值。\n            feetIkPosition.y = feetOutHit.point.y + pelvisOffset; //hit pos 的 Y 赋值\n \n            feetIkRotation = Quaternion.FromToRotation(Vector3.up, feetOutHit.normal) * transform.rotation; //计算法向偏移\n            feetIkRotation = Quaternion.AngleAxis(angleOffset, Vector3.up) * feetIkRotation; //计算额外的偏移\n \n            return;\n        &#125;\n        feetIkPosition = Vector3.zero; //没有hit，归零\n    &#125;\n \n    void AdjustFeetTarget(ref Vector3 feetPosition, HumanBodyBones foot)\n    &#123;\n        \n        feetPosition = m_animator.GetBoneTransform(foot).position; //获取人形足部的transform position\n        feetPosition.y = transform.position.y + heightFromGroundRaycast; //y的值会加上【向上检测的距离】，主要是防止卡模型。\n       \n    &#125;\n    private void OnDrawGizmos()\n    &#123;\n        Gizmos.DrawSphere(rightHitPoint, 1.0f);\n        Gizmos.DrawSphere(leftHitPoint, 0.01f);\n    &#125;\n&#125;\n</Animator></code></pre>\n\n<p>看到上面代码的你肯定是一脸懵逼 ,下面就让我来一一解读、</p>\n<pre><code class=\"csharp\">[RequireComponent(typeof(Animator))]\n</code></pre>\n\n<p>这个提一嘴免得有人还不知道,所挂载的物体上必须要有一个 Animator 组件</p>\n<pre><code class=\"csharp\">\npublic bool enableFeetIk = true; //是否开启ik  \n[Range(0, 2)] [SerializeField] private float heightFromGroundRaycast = 1.2f; //从地面向上的cast距离  \n[Range(0, 2)] [SerializeField] private float raycastDownDistance = 1.5f; //向下cast 距离  \n[SerializeField] private LayerMask environmentLayer; //检测layer  \n[SerializeField] private float pelvisOffset = 0f; //盆骨offset  \n[Range(0, 1)] [SerializeField] private float pelvisUpAndDownSpeed = 0.28f; //盆骨赋值速度  \n[Range(0, 1)] [SerializeField] private float feetToIkPositionSpeed = 0.5f; //足IK赋值速度  \npublic string leftFootAnimCurveName = \"LeftFoot\"; //权重曲线名称  \npublic string rightFootAnimCurveName = \"RightFoot\"; //权重曲线名称  \n[Range(0, 100)] public float leftFootAngleOffset; //旋转偏移  \n[Range(0, 100)] public float rightFootAngleOffset; //旋转偏移  \npublic bool useIkFeature = false; //是否使用IK旋转  \n\npublic bool showSolverDebug = true;// Debug绘制  \n\nprivate Animator m_animator; //动画机  \n\nprivate Vector3 _rightFootPosition, _leftFootPosition; //足部骨骼posiition  \nprivate Vector3 _rightFootIkPosition, _leftFootIkPosition; //足部IK position  \nprivate Quaternion _leftFootIkRotation, _rightFootIkRotation; //足部IK rotation  \nprivate float _lastPelvisPositionY, _lastRightFootPositionY, _lastLeftFootPositionY; //上帧信息，用于lerp动画  \n\n#region for Gizmos  \nprivate Vector3 rightHitPoint;  \nprivate Vector3 leftHitPoint;  \nprivate bool flip = false;  \n#endregion  \n\nprivate void Start()  \n&#123;  \n    m_animator = GetComponent<Animator>();  \n&#125;\n</Animator></code></pre>\n\n<p>这一块代码首先说明一下这个</p>\n<pre><code class=\"csharp\">[Range(0, 2)] [SerializeField]  \n</code></pre>\n\n<p>这个就是表明在 unity3d 编辑器界面的范围,而第二个就是表示可以序列化(说人话就是即使是 private 也可以被修改)</p>\n<p>其他的看看注释就行了</p>\n<pre><code class=\"csharp\">#region for Gizmos  \nprivate Vector3 rightHitPoint;  \nprivate Vector3 leftHitPoint;  \nprivate bool flip = false;\n</code></pre>\n\n<p>这段代码应该是在 unity3d 界面上画的,和具体功能无关,只是想画出接触点的位置不必理会</p>\n<p>来看看 void fixedupdate 里面的 AdjustFeetTarget 这个函数其函数定义如下</p>\n<pre><code class=\"csharp\">void AdjustFeetTarget(ref Vector3 feetPosition, HumanBodyBones foot)  \n&#123;  \n    feetPosition = m_animator.GetBoneTransform(foot).position; //获取人形足部的transform position  \n    feetPosition.y = transform.position.y + heightFromGroundRaycast; //y的值会加上【向上检测的距离】，主要是防止卡模型。  \n&#125;\n</code></pre>\n\n<p>这个函数的作用就是时时刻刻计算出检测点发射的位置,并且通过 ref feetposition 回调,方便下面的检测碰撞体使用,下面就来看看 FootPositionSolver 这个函数</p>\n<pre><code class=\"csharp\">\nvoid FootPositionSolver(Vector3 fromSkyPosition, ref Vector3 feetIkPosition, ref Quaternion feetIkRotation, float angleOffset)  \n&#123;  \n    if (showSolverDebug)  \n    &#123;  \n        Debug.DrawLine(fromSkyPosition, fromSkyPosition + Vector3.down * (raycastDownDistance), Color.green);  \n        Debug.Log(\"fromskyposition:\"+fromSkyPosition);  \n    &#125;  \n\n    if (Physics.Raycast(fromSkyPosition, Vector3.down, out var feetOutHit, raycastDownDistance+ heightFromGroundRaycast, environmentLayer))  \n    &#123;  \n        feetIkPosition = fromSkyPosition; //保存x,z值。  \n        feetIkPosition.y = feetOutHit.point.y + pelvisOffset; //hit pos 的 Y 赋值  \n\n        feetIkRotation = Quaternion.FromToRotation(Vector3.up, feetOutHit.normal) * transform.rotation; //计算法向偏移  \n        feetIkRotation = Quaternion.AngleAxis(angleOffset, Vector3.up) * feetIkRotation; //计算额外的偏移  \n\n        return;  \n    &#125;  \n    feetIkPosition = Vector3.zero; //没有hit，归零  \n&#125;\n</code></pre>\n\n<p>第一个 if 语句就是要不要绘制那条检测射线</p>\n<p>然后第二个判断语句就是检测碰撞体,也十分容易理解</p>\n<p>FromToRotation 函数计算从 Vector3.up 到 feetOutHit.normal 的旋转，这样就可以使角色的脚与地面的法线方向对齐,四元数我现在还没开始学所以只能记住用法了</p>\n<p>feetIkRotation &#x3D; Quaternion.AngleAxis(angleOffset, Vector3.up) * feetIkRotation; &#x2F;&#x2F;计算额外的偏移这个也是一样就是脚掌的向内外偏移</p>\n<p>最后就得到了脚掌的 IK 了</p>\n<p>相反如果没有碰撞体的话就返回零,注意这里没有碰撞体是指悬浮在空中,不是站在地面上,因为站在地面上的碰撞体就是地面</p>\n<p>接下来就是 private void OnAnimatorIK(int layerIndex),这个函数只有在动画设置了 IK pass 的时候才能调用,并且也只能在这里设置 IK 相应的函数</p>\n<pre><code class=\"csharp\">\nprivate void OnAnimatorIK(int layerIndex)  \n&#123;  \n    if (!enableFeetIk) return;  \n    if (!m_animator) return;  \n\n    MovePelvisHeight(); //骨盆偏移  \n\n    m_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //保证行走的时候脚部脱离,不然会粘在地上  \n    if (useIkFeature)  \n    &#123;  \n        m_animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName)); //设置 rot 权重  \n    &#125;  \n    MoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY); //设置ik goal坐标  \n\n    m_animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));  \n    if (useIkFeature)  \n    &#123;  \n        m_animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, m_animator.GetFloat(leftFootAnimCurveName));  \n    &#125;  \n    MoveFeetToIkPoint(AvatarIKGoal.LeftFoot, _leftFootIkPosition, _leftFootIkRotation, ref _lastLeftFootPositionY);  \n&#125;\n</code></pre>\n\n<p>前面两个语句就是防止报错写的不必多想</p>\n<p>我们先说简单的</p>\n<pre><code class=\"csharp\">\nm_animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, m_animator.GetFloat(rightFootAnimCurveName));  \n</code></pre>\n\n<p>这个就是根据动画曲线来设置权重,为什么要这样做捏,因为在人物跑步的时候总不能设置权重为 1 吧,这样就好像人的脚被锁住了,所以这里通过设置动画曲线的形式在和权重联动</p>\n<p>接下来稍微需要一点思考的</p>\n<pre><code class=\"csharp\">\nMoveFeetToIkPoint(AvatarIKGoal.RightFoot, _rightFootIkPosition, _rightFootIkRotation, ref _lastRightFootPositionY);  \n</code></pre>\n\n<pre><code class=\"csharp\">\nvoid MoveFeetToIkPoint(AvatarIKGoal foot, Vector3 positionIkHolder, Quaternion rotationIkHolder, ref float lastFootPositionY)  \n&#123;  \n    Vector3 targetIkPosition = m_animator.GetIKPosition(foot); //获得红色圆球的位置  \n\n    if (positionIkHolder != Vector3.zero) //如果新的IK pos 不为 0   \n    &#123;  \n        targetIkPosition = transform.InverseTransformPoint(targetIkPosition); //把原本的ik goal 的pos转换到本地坐标系  \n        positionIkHolder = transform.InverseTransformPoint(positionIkHolder); //把现在的ik goal 的pos转到本地坐标系  \n\n        float yVar = Mathf.Lerp(lastFootPositionY, positionIkHolder.y, feetToIkPositionSpeed); //进行插值  \n        targetIkPosition.y += yVar;  \n        lastFootPositionY = yVar;  \n\n        targetIkPosition = transform.TransformPoint(targetIkPosition); //把新的ik goal pos转到世界坐标系  \n\n        m_animator.SetIKRotation(foot, rotationIkHolder); //旋转赋予  \n    &#125;  \n    m_animator.SetIKPosition(foot, targetIkPosition); //位置赋予  \n&#125;\n</code></pre>\n\n<p>刚刚说过了如果 IK 等于零的话不就是飞在天上了嘛,所以这种情况就不用判断了<br>这个代码的解决方案就是先将脚踝的 IK(已经经过上面的计算得到了结果)转化成相对于父物体的本地坐标,下面的也是一样</p>\n<p>奇怪的东西就来了你一定会注意到 lastFootPositionY 这个东西在哪里用过,然后按住 Ctrl 点击这个发现只有这里用了,其实这个是因为脚部的初始位置本来就是零,所以这里就直接按照默认值来了,然后又出现了新的问题,就是这个”+&#x3D;”为什么不是”&#x3D;”呢，因为这个是本地坐标也就是脚掌到 IK 原本的距离,然后通过计算从脚踝到碰撞面的距离进行插值这样就可以实现脚部 IK 了</p>\n<p>最后再来介绍一下</p>\n<pre><code class=\"csharp\">\nvoid MovePelvisHeight() //调整pelvis，保证IK 能达到（比如左右脚高度差那种）  \n&#123;  \n    if (_rightFootIkPosition == Vector3.zero || _leftFootIkPosition == Vector3.zero || _lastPelvisPositionY == 0f)  \n    &#123;  \n        _lastPelvisPositionY = m_animator.bodyPosition.y;  \n        return;  \n    &#125;  \n\n    float lOffsetPosition = _leftFootIkPosition.y - transform.position.y; //左脚ik pos与当前transform的高度差  \n    float rOffsetPosition = _rightFootIkPosition.y - transform.position.y; //右脚ik pos 与当前transform的高度差  \n\n    //选择较小值（在以vector3.up为正轴的情况下）  \n    //如果是正值，则向上偏移距离较小的。  \n    //如果是负值，则向下偏移距离较大的。  \n    float totalOffset = (lOffsetPosition < rOffsetPosition) ? lOffsetPosition : rOffsetPosition;  \n\n    Vector3 newPelvisPosition = m_animator.bodyPosition + Vector3.up * totalOffset; //新的骨盆位置计算： 原位置+ up方向 * offset。  \n    newPelvisPosition.y = Mathf.Lerp(_lastPelvisPositionY, newPelvisPosition.y, pelvisUpAndDownSpeed); //插值动画  \n    m_animator.bodyPosition = newPelvisPosition; //赋值  \n    _lastPelvisPositionY = m_animator.bodyPosition.y; //记录信息  \n&#125;\n</code></pre>\n\n<p>至于为什么要写这个代码需要大伙想一想因为当左右脚有差距的时候如果身体不移动的话也不太可能将脚贴近地面的吧,所以要根据双脚的差距来矫正位置<br>  <img src=\"/2024/09/27/Foot-IK/footik.jpg\"><br>结合一下这幅图应该就看明白了</p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-09-25T05:09:49.961Z","updated":"2024-09-27T11:30:22.998Z","comments":1,"layout":"post","photos":[],"_id":"cm1muoetx0004sc7q1u5a28yt","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/C-事件详解/event.jpg","slug":"event.jpg","post":"cm1muoetp0000sc7qfqhmh31m","modified":0,"renderable":0},{"_id":"source/_posts/C-事件详解/事件1.jpg","slug":"事件1.jpg","post":"cm1muoetp0000sc7qfqhmh31m","modified":0,"renderable":0},{"_id":"source/_posts/C-事件详解/事件2.jpg","slug":"事件2.jpg","post":"cm1muoetp0000sc7qfqhmh31m","modified":0,"renderable":0},{"_id":"source/_posts/C-事件详解/事件三.jpg","slug":"事件三.jpg","post":"cm1muoetp0000sc7qfqhmh31m","modified":0,"renderable":0},{"_id":"source/_posts/Foot-IK/anbi1.jpg","slug":"anbi1.jpg","post":"cm1muoetw0003sc7q7qvehoko","modified":0,"renderable":0},{"_id":"source/_posts/Foot-IK/anbi2.jpg","slug":"anbi2.jpg","post":"cm1muoetw0003sc7q7qvehoko","modified":0,"renderable":0},{"_id":"source/_posts/Foot-IK/anbi3.jpg","slug":"anbi3.jpg","post":"cm1muoetw0003sc7q7qvehoko","modified":0,"renderable":0},{"_id":"source/_posts/Foot-IK/footik.jpg","slug":"footik.jpg","post":"cm1muoetw0003sc7q7qvehoko","modified":0,"renderable":0},{"_id":"source/_posts/Foot-IK/NO.01.001.jpg","slug":"NO.01.001.jpg","post":"cm1muoetw0003sc7q7qvehoko","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cm1muoetp0000sc7qfqhmh31m","tag_id":"cm1muoetu0001sc7q4pov8nch","_id":"cm1muoetv0002sc7q8fwchom1"},{"post_id":"cm1muoetw0003sc7q7qvehoko","tag_id":"cm1muoetu0001sc7q4pov8nch","_id":"cm1muoety0005sc7q2yen3j9o"}],"Tag":[{"name":"Unity 3d C#","_id":"cm1muoetu0001sc7q4pov8nch"}]}}